$ErrorActionPreference = "Stop"

# ===== CONFIG =====
$UserUpn   = "user@domain.com"
$GroupName = "My Security Group"
# ==================

# Resolve user object ID
$UserId = (az ad user show --id $UserUpn --query id -o tsv).Trim()
if (-not $UserId) { throw "User not found: $UserUpn" }

# Resolve group object ID
$GroupId = (az ad group list `
    --filter "displayName eq '$GroupName'" `
    --query "[0].id" -o tsv).Trim()

if (-not $GroupId) { throw "Group not found: $GroupName" }

# Check if user already member
$already = az rest --method GET `
  --url "https://graph.microsoft.com/v1.0/groups/$GroupId/members?`$select=id" `
  --query "value[?id=='$UserId'] | length(@)" `
  -o tsv

if ([int]$already -gt 0) {
    Write-Host "User '$UserUpn' is already in group '$GroupName'"
    exit 0
}

# Build JSON body
$Body = '{"@odata.id":"https://graph.microsoft.com/v1.0/directoryObjects/' + $UserId + '"}'

# Add user to group
az rest --method POST `
  --url "https://graph.microsoft.com/v1.0/groups/$GroupId/members/`$ref" `
  --headers "Content-Type=application/json" `
  --body $Body | Out-Null

Write-Host "Added '$UserUpn' to group '$GroupName'"

# Verify membership
az rest --method GET `
  --url "https://graph.microsoft.com/v1.0/groups/$GroupId/members?`$select=displayName,userPrincipalName,id" `
  --query "value[].{displayName:displayName, userPrincipalName:userPrincipalName, id:id}" `
  -o table


# group type
$GroupId = (az ad group list --filter "displayName eq 'SEC-PIM-Global Administrator Role'" --query "[0].id" -o tsv).Trim()
az rest --method GET --url "https://graph.microsoft.com/v1.0/groups/$GroupId?`$select=id,displayName,isAssignableToRole" -o json



$ErrorActionPreference = "Stop"

$UserUpn = "user@domain.com"

# Option 1 (simplest): use UPN directly in the Graph URL
$url = "https://graph.microsoft.com/v1.0/users/$($UserUpn)?`$select=displayName,userPrincipalName,signInActivity"

az rest --method GET --url $url `
  --query "{User:userPrincipalName, LastInteractive:signInActivity.lastSignInDateTime, LastNonInteractive:signInActivity.lastNonInteractiveSignInDateTime, LastSuccessful:signInActivity.lastSuccessfulSignInDateTime}" `
  -o table

#key vaults

$ErrorActionPreference = "Continue"

$results = @()

# Get all subscriptions
$subs = az account list --query "[].{id:id,name:name}" -o json | ConvertFrom-Json

foreach ($sub in $subs) {

    Write-Host "`n===== Subscription: $($sub.name) ====="

    az account set --subscription $sub.id | Out-Null

    # Get vaults in subscription
    $vaults = az keyvault list `
        --query "[].{name:name, rg:resourceGroup, location:location, id:id}" `
        -o json | ConvertFrom-Json

    foreach ($vault in $vaults) {

        Write-Host "Vault: $($vault.name)"

        # Get vault properties (RBAC vs Access Policy)
        $vaultProps = az keyvault show `
            --name $vault.name `
            --query "{rbac:properties.enableRbacAuthorization, tenantId:properties.tenantId}" `
            -o json 2>$null | ConvertFrom-Json

        # List secrets (metadata only)
        $secrets = az keyvault secret list `
            --vault-name $vault.name `
            --query "[].{name:name, enabled:attributes.enabled, created:attributes.created, updated:attributes.updated, expires:attributes.expires}" `
            -o json 2>$null

        if ($LASTEXITCODE -ne 0) {
            Write-Host "  Unable to list secrets (no permission?)"
            continue
        }

        $secrets = $secrets | ConvertFrom-Json

        if (-not $secrets) {
            Write-Host "  No secrets found."
            continue
        }

        foreach ($secret in $secrets) {

            # Simple heuristic risk tagging
            $riskTag = $null
            $lower = $secret.name.ToLower()

            if ($lower -match "secret|client|app|sp|cert|pfx|token|password|pwd") {
                $riskTag = "PotentialCredential"
            }

            $results += [PSCustomObject]@{
                SubscriptionName = $sub.name
                SubscriptionId   = $sub.id
                VaultName        = $vault.name
                ResourceGroup    = $vault.rg
                Location         = $vault.location
                RBACEnabled      = $vaultProps.rbac
                SecretName       = $secret.name
                Enabled          = $secret.enabled
                Created          = $secret.created
                Updated          = $secret.updated
                Expires          = $secret.expires
                RiskFlag         = $riskTag
            }
        }
    }
}

# Export results
$outputFile = "KeyVault_Full_Audit_$(Get-Date -Format yyyyMMdd_HHmmss).csv"
$results | Export-Csv $outputFile -NoTypeInformation -Encoding UTF8

Write-Host "`nAudit complete."
Write-Host "Results saved to: $outputFile"



===== copy group membership

$ErrorActionPreference = "Stop"

# ===== CONFIG =====
$SourceUserUpn = "source@domain.com"   # copy FROM
$TargetUserUpn = "target@domain.com"   # copy TO
# ==================

function Get-UserId([string]$upn) {
  $id = (az ad user show --id $upn --query id -o tsv).Trim()
  if (-not $id) { throw "Could not resolve user id for: $upn" }
  return $id
}

function Get-AllPages([string]$url) {
  $items = @()
  while ($url) {
    $page = az rest --method GET --url $url -o json | ConvertFrom-Json
    if ($page.value) { $items += $page.value }
    $url = $page.'@odata.nextLink'
  }
  return $items
}

$SourceUserId = Get-UserId $SourceUserUpn
$TargetUserId = Get-UserId $TargetUserUpn

Write-Host "Source: $SourceUserUpn ($SourceUserId)"
Write-Host "Target: $TargetUserUpn ($TargetUserId)"
Write-Host ""

# 1) Get direct group memberships for source user (only Groups)
# memberOf can include directory roles too; filter to group objects
$memberOfUrl = "https://graph.microsoft.com/v1.0/users/$SourceUserId/memberOf/microsoft.graph.group?`$select=id,displayName,groupTypes,isAssignableToRole,membershipRule"
$sourceGroups = Get-AllPages $memberOfUrl

if (-not $sourceGroups -or $sourceGroups.Count -eq 0) {
  Write-Host "No groups found for source user."
  exit 0
}

Write-Host "Source is in $($sourceGroups.Count) groups (direct memberships)."

# 2) For each group, decide if it's safe to add target user and then add
$added = 0
$skipped = 0
$failed = 0

foreach ($g in $sourceGroups) {
  $groupId = $g.id
  $groupName = $g.displayName

  # Skip role-assignable groups (often needs RoleManagement permissions)
  if ($g.isAssignableToRole -eq $true) {
    Write-Host "SKIP (role-assignable): $groupName"
    $skipped++
    continue
  }

  # Skip dynamic membership groups (you can't manually add members)
  # groupTypes may contain "DynamicMembership"; membershipRule may be present
  $isDynamic = $false
  if ($g.groupTypes -and ($g.groupTypes -contains "DynamicMembership")) { $isDynamic = $true }
  if ($g.membershipRule) { $isDynamic = $true }

  if ($isDynamic) {
    Write-Host "SKIP (dynamic group): $groupName"
    $skipped++
    continue
  }

  # Check if target user already a member
  $already = az rest --method GET `
    --url "https://graph.microsoft.com/v1.0/groups/$groupId/members?`$select=id" `
    --query "value[?id=='$TargetUserId'] | length(@)" `
    -o tsv

  if ([int]$already -gt 0) {
    Write-Host "OK (already member): $groupName"
    $skipped++
    continue
  }

  # Add target user
  $Body = '{"@odata.id":"https://graph.microsoft.com/v1.0/directoryObjects/' + $TargetUserId + '"}'

  try {
    az rest --method POST `
      --url "https://graph.microsoft.com/v1.0/groups/$groupId/members/`$ref" `
      --headers "Content-Type=application/json" `
      --body $Body | Out-Null

    Write-Host "ADDED: $groupName"
    $added++
  }
  catch {
    Write-Host "FAILED: $groupName"
    $failed++
  }
}

Write-Host ""
Write-Host "Done. Added=$added  Skipped=$skipped  Failed=$failed"
